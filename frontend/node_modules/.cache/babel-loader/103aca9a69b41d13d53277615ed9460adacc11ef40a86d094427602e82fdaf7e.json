{"ast":null,"code":"import { getAddress } from \"../address/index.js\";\nimport { ZeroAddress } from \"../constants/addresses.js\";\nimport { keccak256, sha256, Signature, SigningKey } from \"../crypto/index.js\";\nimport { concat, decodeRlp, encodeRlp, getBytes, getBigInt, getNumber, hexlify, assert, assertArgument, isBytesLike, isHexString, toBeArray, zeroPadValue } from \"../utils/index.js\";\nimport { accessListify } from \"./accesslist.js\";\nimport { authorizationify } from \"./authorization.js\";\nimport { recoverAddress } from \"./address.js\";\nconst BN_0 = BigInt(0);\nconst BN_2 = BigInt(2);\nconst BN_27 = BigInt(27);\nconst BN_28 = BigInt(28);\nconst BN_35 = BigInt(35);\nconst BN_MAX_UINT = BigInt(\"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\");\nconst inspect = Symbol.for(\"nodejs.util.inspect.custom\");\nconst BLOB_SIZE = 4096 * 32;\nconst CELL_COUNT = 128;\n/**\n *  Returns a BLOb proof as its cells for [[link-eip-7594]] BLOb.\n *\n *  The default %%cellCount%% is 128.\n */\nexport function splitBlobCells(_proof, cellCount) {\n  if (cellCount == null) {\n    cellCount = CELL_COUNT;\n  }\n  const cellProofs = [];\n  const proof = getBytes(_proof);\n  const cellSize = proof.length / cellCount;\n  for (let i = 0; i < proof.length; i += cellSize) {\n    cellProofs.push(hexlify(proof.subarray(i, i + cellSize)));\n  }\n  return cellProofs;\n}\nfunction getKzgLibrary(kzg) {\n  const blobToKzgCommitment = blob => {\n    if (\"computeBlobProof\" in kzg) {\n      // micro-ecc-signer; check for computeBlobProof since this API\n      // expects a string while the kzg-wasm below expects a Unit8Array\n      if (\"blobToKzgCommitment\" in kzg && typeof kzg.blobToKzgCommitment === \"function\") {\n        return getBytes(kzg.blobToKzgCommitment(hexlify(blob)));\n      }\n    } else if (\"blobToKzgCommitment\" in kzg && typeof kzg.blobToKzgCommitment === \"function\") {\n      // kzg-wasm <0.5.0; blobToKzgCommitment(Uint8Array) => Uint8Array\n      return getBytes(kzg.blobToKzgCommitment(blob));\n    }\n    // kzg-wasm >= 0.5.0; blobToKZGCommitment(string) => string\n    if (\"blobToKZGCommitment\" in kzg && typeof kzg.blobToKZGCommitment === \"function\") {\n      return getBytes(kzg.blobToKZGCommitment(hexlify(blob)));\n    }\n    assertArgument(false, \"unsupported KZG library\", \"kzg\", kzg);\n  };\n  const computeBlobKzgProof = (blob, commitment) => {\n    // micro-ecc-signer\n    if (\"computeBlobProof\" in kzg && typeof kzg.computeBlobProof === \"function\") {\n      return getBytes(kzg.computeBlobProof(hexlify(blob), hexlify(commitment)));\n    }\n    // kzg-wasm <0.5.0; computeBlobKzgProof(Uint8Array, Uint8Array) => Uint8Array\n    if (\"computeBlobKzgProof\" in kzg && typeof kzg.computeBlobKzgProof === \"function\") {\n      return kzg.computeBlobKzgProof(blob, commitment);\n    }\n    // kzg-wasm >= 0.5.0; computeBlobKZGProof(string, string) => string\n    if (\"computeBlobKZGProof\" in kzg && typeof kzg.computeBlobKZGProof === \"function\") {\n      return getBytes(kzg.computeBlobKZGProof(hexlify(blob), hexlify(commitment)));\n    }\n    assertArgument(false, \"unsupported KZG library\", \"kzg\", kzg);\n  };\n  return {\n    blobToKzgCommitment,\n    computeBlobKzgProof\n  };\n}\nfunction getVersionedHash(version, hash) {\n  let versioned = version.toString(16);\n  while (versioned.length < 2) {\n    versioned = \"0\" + versioned;\n  }\n  versioned += sha256(hash).substring(4);\n  return \"0x\" + versioned;\n}\nfunction handleAddress(value) {\n  if (value === \"0x\") {\n    return null;\n  }\n  return getAddress(value);\n}\nfunction handleAccessList(value, param) {\n  try {\n    return accessListify(value);\n  } catch (error) {\n    assertArgument(false, error.message, param, value);\n  }\n}\nfunction handleAuthorizationList(value, param) {\n  try {\n    if (!Array.isArray(value)) {\n      throw new Error(\"authorizationList: invalid array\");\n    }\n    const result = [];\n    for (let i = 0; i < value.length; i++) {\n      const auth = value[i];\n      if (!Array.isArray(auth)) {\n        throw new Error(`authorization[${i}]: invalid array`);\n      }\n      if (auth.length !== 6) {\n        throw new Error(`authorization[${i}]: wrong length`);\n      }\n      if (!auth[1]) {\n        throw new Error(`authorization[${i}]: null address`);\n      }\n      result.push({\n        address: handleAddress(auth[1]),\n        nonce: handleUint(auth[2], \"nonce\"),\n        chainId: handleUint(auth[0], \"chainId\"),\n        signature: Signature.from({\n          yParity: handleNumber(auth[3], \"yParity\"),\n          r: zeroPadValue(auth[4], 32),\n          s: zeroPadValue(auth[5], 32)\n        })\n      });\n    }\n    return result;\n  } catch (error) {\n    assertArgument(false, error.message, param, value);\n  }\n}\nfunction handleNumber(_value, param) {\n  if (_value === \"0x\") {\n    return 0;\n  }\n  return getNumber(_value, param);\n}\nfunction handleUint(_value, param) {\n  if (_value === \"0x\") {\n    return BN_0;\n  }\n  const value = getBigInt(_value, param);\n  assertArgument(value <= BN_MAX_UINT, \"value exceeds uint size\", param, value);\n  return value;\n}\nfunction formatNumber(_value, name) {\n  const value = getBigInt(_value, \"value\");\n  const result = toBeArray(value);\n  assertArgument(result.length <= 32, `value too large`, `tx.${name}`, value);\n  return result;\n}\nfunction formatAccessList(value) {\n  return accessListify(value).map(set => [set.address, set.storageKeys]);\n}\nfunction formatAuthorizationList(value) {\n  return value.map(a => {\n    return [formatNumber(a.chainId, \"chainId\"), a.address, formatNumber(a.nonce, \"nonce\"), formatNumber(a.signature.yParity, \"yParity\"), toBeArray(a.signature.r), toBeArray(a.signature._s)];\n  });\n}\nfunction formatHashes(value, param) {\n  assertArgument(Array.isArray(value), `invalid ${param}`, \"value\", value);\n  for (let i = 0; i < value.length; i++) {\n    assertArgument(isHexString(value[i], 32), \"invalid ${ param } hash\", `value[${i}]`, value[i]);\n  }\n  return value;\n}\nfunction _parseLegacy(data) {\n  const fields = decodeRlp(data);\n  assertArgument(Array.isArray(fields) && (fields.length === 9 || fields.length === 6), \"invalid field count for legacy transaction\", \"data\", data);\n  const tx = {\n    type: 0,\n    nonce: handleNumber(fields[0], \"nonce\"),\n    gasPrice: handleUint(fields[1], \"gasPrice\"),\n    gasLimit: handleUint(fields[2], \"gasLimit\"),\n    to: handleAddress(fields[3]),\n    value: handleUint(fields[4], \"value\"),\n    data: hexlify(fields[5]),\n    chainId: BN_0\n  };\n  // Legacy unsigned transaction\n  if (fields.length === 6) {\n    return tx;\n  }\n  const v = handleUint(fields[6], \"v\");\n  const r = handleUint(fields[7], \"r\");\n  const s = handleUint(fields[8], \"s\");\n  if (r === BN_0 && s === BN_0) {\n    // EIP-155 unsigned transaction\n    tx.chainId = v;\n  } else {\n    // Compute the EIP-155 chain ID (or 0 for legacy)\n    let chainId = (v - BN_35) / BN_2;\n    if (chainId < BN_0) {\n      chainId = BN_0;\n    }\n    tx.chainId = chainId;\n    // Signed Legacy Transaction\n    assertArgument(chainId !== BN_0 || v === BN_27 || v === BN_28, \"non-canonical legacy v\", \"v\", fields[6]);\n    tx.signature = Signature.from({\n      r: zeroPadValue(fields[7], 32),\n      s: zeroPadValue(fields[8], 32),\n      v\n    });\n    //tx.hash = keccak256(data);\n  }\n  return tx;\n}\nfunction _serializeLegacy(tx, sig) {\n  const fields = [formatNumber(tx.nonce, \"nonce\"), formatNumber(tx.gasPrice || 0, \"gasPrice\"), formatNumber(tx.gasLimit, \"gasLimit\"), tx.to || \"0x\", formatNumber(tx.value, \"value\"), tx.data];\n  let chainId = BN_0;\n  if (tx.chainId != BN_0) {\n    // A chainId was provided; if non-zero we'll use EIP-155\n    chainId = getBigInt(tx.chainId, \"tx.chainId\");\n    // We have a chainId in the tx and an EIP-155 v in the signature,\n    // make sure they agree with each other\n    assertArgument(!sig || sig.networkV == null || sig.legacyChainId === chainId, \"tx.chainId/sig.v mismatch\", \"sig\", sig);\n  } else if (tx.signature) {\n    // No explicit chainId, but EIP-155 have a derived implicit chainId\n    const legacy = tx.signature.legacyChainId;\n    if (legacy != null) {\n      chainId = legacy;\n    }\n  }\n  // Requesting an unsigned transaction\n  if (!sig) {\n    // We have an EIP-155 transaction (chainId was specified and non-zero)\n    if (chainId !== BN_0) {\n      fields.push(toBeArray(chainId));\n      fields.push(\"0x\");\n      fields.push(\"0x\");\n    }\n    return encodeRlp(fields);\n  }\n  // @TODO: We should probably check that tx.signature, chainId, and sig\n  //        match but that logic could break existing code, so schedule\n  //        this for the next major bump.\n  // Compute the EIP-155 v\n  let v = BigInt(27 + sig.yParity);\n  if (chainId !== BN_0) {\n    v = Signature.getChainIdV(chainId, sig.v);\n  } else if (BigInt(sig.v) !== v) {\n    assertArgument(false, \"tx.chainId/sig.v mismatch\", \"sig\", sig);\n  }\n  // Add the signature\n  fields.push(toBeArray(v));\n  fields.push(toBeArray(sig.r));\n  fields.push(toBeArray(sig._s));\n  return encodeRlp(fields);\n}\nfunction _parseEipSignature(tx, fields) {\n  let yParity;\n  try {\n    yParity = handleNumber(fields[0], \"yParity\");\n    if (yParity !== 0 && yParity !== 1) {\n      throw new Error(\"bad yParity\");\n    }\n  } catch (error) {\n    assertArgument(false, \"invalid yParity\", \"yParity\", fields[0]);\n  }\n  const r = zeroPadValue(fields[1], 32);\n  const s = zeroPadValue(fields[2], 32);\n  const signature = Signature.from({\n    r,\n    s,\n    yParity\n  });\n  tx.signature = signature;\n}\nfunction _parseEip1559(data) {\n  const fields = decodeRlp(getBytes(data).slice(1));\n  assertArgument(Array.isArray(fields) && (fields.length === 9 || fields.length === 12), \"invalid field count for transaction type: 2\", \"data\", hexlify(data));\n  const tx = {\n    type: 2,\n    chainId: handleUint(fields[0], \"chainId\"),\n    nonce: handleNumber(fields[1], \"nonce\"),\n    maxPriorityFeePerGas: handleUint(fields[2], \"maxPriorityFeePerGas\"),\n    maxFeePerGas: handleUint(fields[3], \"maxFeePerGas\"),\n    gasPrice: null,\n    gasLimit: handleUint(fields[4], \"gasLimit\"),\n    to: handleAddress(fields[5]),\n    value: handleUint(fields[6], \"value\"),\n    data: hexlify(fields[7]),\n    accessList: handleAccessList(fields[8], \"accessList\")\n  };\n  // Unsigned EIP-1559 Transaction\n  if (fields.length === 9) {\n    return tx;\n  }\n  //tx.hash = keccak256(data);\n  _parseEipSignature(tx, fields.slice(9));\n  return tx;\n}\nfunction _serializeEip1559(tx, sig) {\n  const fields = [formatNumber(tx.chainId, \"chainId\"), formatNumber(tx.nonce, \"nonce\"), formatNumber(tx.maxPriorityFeePerGas || 0, \"maxPriorityFeePerGas\"), formatNumber(tx.maxFeePerGas || 0, \"maxFeePerGas\"), formatNumber(tx.gasLimit, \"gasLimit\"), tx.to || \"0x\", formatNumber(tx.value, \"value\"), tx.data, formatAccessList(tx.accessList || [])];\n  if (sig) {\n    fields.push(formatNumber(sig.yParity, \"yParity\"));\n    fields.push(toBeArray(sig.r));\n    fields.push(toBeArray(sig.s));\n  }\n  return concat([\"0x02\", encodeRlp(fields)]);\n}\nfunction _parseEip2930(data) {\n  const fields = decodeRlp(getBytes(data).slice(1));\n  assertArgument(Array.isArray(fields) && (fields.length === 8 || fields.length === 11), \"invalid field count for transaction type: 1\", \"data\", hexlify(data));\n  const tx = {\n    type: 1,\n    chainId: handleUint(fields[0], \"chainId\"),\n    nonce: handleNumber(fields[1], \"nonce\"),\n    gasPrice: handleUint(fields[2], \"gasPrice\"),\n    gasLimit: handleUint(fields[3], \"gasLimit\"),\n    to: handleAddress(fields[4]),\n    value: handleUint(fields[5], \"value\"),\n    data: hexlify(fields[6]),\n    accessList: handleAccessList(fields[7], \"accessList\")\n  };\n  // Unsigned EIP-2930 Transaction\n  if (fields.length === 8) {\n    return tx;\n  }\n  //tx.hash = keccak256(data);\n  _parseEipSignature(tx, fields.slice(8));\n  return tx;\n}\nfunction _serializeEip2930(tx, sig) {\n  const fields = [formatNumber(tx.chainId, \"chainId\"), formatNumber(tx.nonce, \"nonce\"), formatNumber(tx.gasPrice || 0, \"gasPrice\"), formatNumber(tx.gasLimit, \"gasLimit\"), tx.to || \"0x\", formatNumber(tx.value, \"value\"), tx.data, formatAccessList(tx.accessList || [])];\n  if (sig) {\n    fields.push(formatNumber(sig.yParity, \"recoveryParam\"));\n    fields.push(toBeArray(sig.r));\n    fields.push(toBeArray(sig.s));\n  }\n  return concat([\"0x01\", encodeRlp(fields)]);\n}\nfunction _parseEip4844(data) {\n  let fields = decodeRlp(getBytes(data).slice(1));\n  let typeName = \"3\";\n  let blobWrapperVersion = null;\n  let blobs = null;\n  // Parse the network format\n  if (fields.length === 4 && Array.isArray(fields[0])) {\n    // EIP-4844 format with sidecar\n    typeName = \"3 (network format)\";\n    const fBlobs = fields[1],\n      fCommits = fields[2],\n      fProofs = fields[3];\n    assertArgument(Array.isArray(fBlobs), \"invalid network format: blobs not an array\", \"fields[1]\", fBlobs);\n    assertArgument(Array.isArray(fCommits), \"invalid network format: commitments not an array\", \"fields[2]\", fCommits);\n    assertArgument(Array.isArray(fProofs), \"invalid network format: proofs not an array\", \"fields[3]\", fProofs);\n    assertArgument(fBlobs.length === fCommits.length, \"invalid network format: blobs/commitments length mismatch\", \"fields\", fields);\n    assertArgument(fBlobs.length === fProofs.length, \"invalid network format: blobs/proofs length mismatch\", \"fields\", fields);\n    blobs = [];\n    for (let i = 0; i < fields[1].length; i++) {\n      blobs.push({\n        data: fBlobs[i],\n        commitment: fCommits[i],\n        proof: fProofs[i]\n      });\n    }\n    fields = fields[0];\n  } else if (fields.length === 5 && Array.isArray(fields[0])) {\n    // EIP-7594 format with sidecar\n    typeName = \"3 (EIP-7594 network format)\";\n    blobWrapperVersion = getNumber(fields[1]);\n    const fBlobs = fields[2],\n      fCommits = fields[3],\n      fProofs = fields[4];\n    assertArgument(blobWrapperVersion === 1, `unsupported EIP-7594 network format version: ${blobWrapperVersion}`, \"fields[1]\", blobWrapperVersion);\n    assertArgument(Array.isArray(fBlobs), \"invalid EIP-7594 network format: blobs not an array\", \"fields[2]\", fBlobs);\n    assertArgument(Array.isArray(fCommits), \"invalid EIP-7594 network format: commitments not an array\", \"fields[3]\", fCommits);\n    assertArgument(Array.isArray(fProofs), \"invalid EIP-7594 network format: proofs not an array\", \"fields[4]\", fProofs);\n    assertArgument(fBlobs.length === fCommits.length, \"invalid network format: blobs/commitments length mismatch\", \"fields\", fields);\n    assertArgument(fBlobs.length * CELL_COUNT === fProofs.length, \"invalid network format: blobs/proofs length mismatch\", \"fields\", fields);\n    blobs = [];\n    for (let i = 0; i < fBlobs.length; i++) {\n      const proof = [];\n      for (let j = 0; j < CELL_COUNT; j++) {\n        proof.push(fProofs[i * CELL_COUNT + j]);\n      }\n      blobs.push({\n        data: fBlobs[i],\n        commitment: fCommits[i],\n        proof: concat(proof)\n      });\n    }\n    fields = fields[0];\n  }\n  assertArgument(Array.isArray(fields) && (fields.length === 11 || fields.length === 14), `invalid field count for transaction type: ${typeName}`, \"data\", hexlify(data));\n  const tx = {\n    type: 3,\n    chainId: handleUint(fields[0], \"chainId\"),\n    nonce: handleNumber(fields[1], \"nonce\"),\n    maxPriorityFeePerGas: handleUint(fields[2], \"maxPriorityFeePerGas\"),\n    maxFeePerGas: handleUint(fields[3], \"maxFeePerGas\"),\n    gasPrice: null,\n    gasLimit: handleUint(fields[4], \"gasLimit\"),\n    to: handleAddress(fields[5]),\n    value: handleUint(fields[6], \"value\"),\n    data: hexlify(fields[7]),\n    accessList: handleAccessList(fields[8], \"accessList\"),\n    maxFeePerBlobGas: handleUint(fields[9], \"maxFeePerBlobGas\"),\n    blobVersionedHashes: fields[10],\n    blobWrapperVersion\n  };\n  if (blobs) {\n    tx.blobs = blobs;\n  }\n  assertArgument(tx.to != null, `invalid address for transaction type: ${typeName}`, \"data\", data);\n  assertArgument(Array.isArray(tx.blobVersionedHashes), \"invalid blobVersionedHashes: must be an array\", \"data\", data);\n  for (let i = 0; i < tx.blobVersionedHashes.length; i++) {\n    assertArgument(isHexString(tx.blobVersionedHashes[i], 32), `invalid blobVersionedHash at index ${i}: must be length 32`, \"data\", data);\n  }\n  // Unsigned EIP-4844 Transaction\n  if (fields.length === 11) {\n    return tx;\n  }\n  // @TODO: Do we need to do this? This is only called internally\n  // and used to verify hashes; it might save time to not do this\n  //tx.hash = keccak256(concat([ \"0x03\", encodeRlp(fields) ]));\n  _parseEipSignature(tx, fields.slice(11));\n  return tx;\n}\nfunction _serializeEip4844(tx, sig, blobs) {\n  const fields = [formatNumber(tx.chainId, \"chainId\"), formatNumber(tx.nonce, \"nonce\"), formatNumber(tx.maxPriorityFeePerGas || 0, \"maxPriorityFeePerGas\"), formatNumber(tx.maxFeePerGas || 0, \"maxFeePerGas\"), formatNumber(tx.gasLimit, \"gasLimit\"), tx.to || ZeroAddress, formatNumber(tx.value, \"value\"), tx.data, formatAccessList(tx.accessList || []), formatNumber(tx.maxFeePerBlobGas || 0, \"maxFeePerBlobGas\"), formatHashes(tx.blobVersionedHashes || [], \"blobVersionedHashes\")];\n  if (sig) {\n    fields.push(formatNumber(sig.yParity, \"yParity\"));\n    fields.push(toBeArray(sig.r));\n    fields.push(toBeArray(sig.s));\n    // We have blobs; return the network wrapped format\n    if (blobs) {\n      // Use EIP-7594\n      if (tx.blobWrapperVersion != null) {\n        const wrapperVersion = toBeArray(tx.blobWrapperVersion);\n        const cellProofs = [];\n        for (const {\n          proof\n        } of blobs) {\n          const p = getBytes(proof);\n          const cellSize = p.length / CELL_COUNT;\n          for (let i = 0; i < p.length; i += cellSize) {\n            cellProofs.push(p.subarray(i, i + cellSize));\n          }\n        }\n        return concat([\"0x03\", encodeRlp([fields, wrapperVersion, blobs.map(b => b.data), blobs.map(b => b.commitment), cellProofs])]);\n      }\n      // Fall back onto classic EIP-4844 behavior\n      return concat([\"0x03\", encodeRlp([fields, blobs.map(b => b.data), blobs.map(b => b.commitment), blobs.map(b => b.proof)])]);\n    }\n  }\n  return concat([\"0x03\", encodeRlp(fields)]);\n}\nfunction _parseEip7702(data) {\n  const fields = decodeRlp(getBytes(data).slice(1));\n  assertArgument(Array.isArray(fields) && (fields.length === 10 || fields.length === 13), \"invalid field count for transaction type: 4\", \"data\", hexlify(data));\n  const tx = {\n    type: 4,\n    chainId: handleUint(fields[0], \"chainId\"),\n    nonce: handleNumber(fields[1], \"nonce\"),\n    maxPriorityFeePerGas: handleUint(fields[2], \"maxPriorityFeePerGas\"),\n    maxFeePerGas: handleUint(fields[3], \"maxFeePerGas\"),\n    gasPrice: null,\n    gasLimit: handleUint(fields[4], \"gasLimit\"),\n    to: handleAddress(fields[5]),\n    value: handleUint(fields[6], \"value\"),\n    data: hexlify(fields[7]),\n    accessList: handleAccessList(fields[8], \"accessList\"),\n    authorizationList: handleAuthorizationList(fields[9], \"authorizationList\")\n  };\n  // Unsigned EIP-7702 Transaction\n  if (fields.length === 10) {\n    return tx;\n  }\n  _parseEipSignature(tx, fields.slice(10));\n  return tx;\n}\nfunction _serializeEip7702(tx, sig) {\n  const fields = [formatNumber(tx.chainId, \"chainId\"), formatNumber(tx.nonce, \"nonce\"), formatNumber(tx.maxPriorityFeePerGas || 0, \"maxPriorityFeePerGas\"), formatNumber(tx.maxFeePerGas || 0, \"maxFeePerGas\"), formatNumber(tx.gasLimit, \"gasLimit\"), tx.to || \"0x\", formatNumber(tx.value, \"value\"), tx.data, formatAccessList(tx.accessList || []), formatAuthorizationList(tx.authorizationList || [])];\n  if (sig) {\n    fields.push(formatNumber(sig.yParity, \"yParity\"));\n    fields.push(toBeArray(sig.r));\n    fields.push(toBeArray(sig.s));\n  }\n  return concat([\"0x04\", encodeRlp(fields)]);\n}\n/**\n *  A **Transaction** describes an operation to be executed on\n *  Ethereum by an Externally Owned Account (EOA). It includes\n *  who (the [[to]] address), what (the [[data]]) and how much (the\n *  [[value]] in ether) the operation should entail.\n *\n *  @example:\n *    tx = new Transaction()\n *    //_result:\n *\n *    tx.data = \"0x1234\";\n *    //_result:\n */\nexport class Transaction {\n  #type;\n  #to;\n  #data;\n  #nonce;\n  #gasLimit;\n  #gasPrice;\n  #maxPriorityFeePerGas;\n  #maxFeePerGas;\n  #value;\n  #chainId;\n  #sig;\n  #accessList;\n  #maxFeePerBlobGas;\n  #blobVersionedHashes;\n  #kzg;\n  #blobs;\n  #auths;\n  #blobWrapperVersion;\n  /**\n   *  The transaction type.\n   *\n   *  If null, the type will be automatically inferred based on\n   *  explicit properties.\n   */\n  get type() {\n    return this.#type;\n  }\n  set type(value) {\n    switch (value) {\n      case null:\n        this.#type = null;\n        break;\n      case 0:\n      case \"legacy\":\n        this.#type = 0;\n        break;\n      case 1:\n      case \"berlin\":\n      case \"eip-2930\":\n        this.#type = 1;\n        break;\n      case 2:\n      case \"london\":\n      case \"eip-1559\":\n        this.#type = 2;\n        break;\n      case 3:\n      case \"cancun\":\n      case \"eip-4844\":\n        this.#type = 3;\n        break;\n      case 4:\n      case \"pectra\":\n      case \"eip-7702\":\n        this.#type = 4;\n        break;\n      default:\n        assertArgument(false, \"unsupported transaction type\", \"type\", value);\n    }\n  }\n  /**\n   *  The name of the transaction type.\n   */\n  get typeName() {\n    switch (this.type) {\n      case 0:\n        return \"legacy\";\n      case 1:\n        return \"eip-2930\";\n      case 2:\n        return \"eip-1559\";\n      case 3:\n        return \"eip-4844\";\n      case 4:\n        return \"eip-7702\";\n    }\n    return null;\n  }\n  /**\n   *  The ``to`` address for the transaction or ``null`` if the\n   *  transaction is an ``init`` transaction.\n   */\n  get to() {\n    const value = this.#to;\n    if (value == null && this.type === 3) {\n      return ZeroAddress;\n    }\n    return value;\n  }\n  set to(value) {\n    this.#to = value == null ? null : getAddress(value);\n  }\n  /**\n   *  The transaction nonce.\n   */\n  get nonce() {\n    return this.#nonce;\n  }\n  set nonce(value) {\n    this.#nonce = getNumber(value, \"value\");\n  }\n  /**\n   *  The gas limit.\n   */\n  get gasLimit() {\n    return this.#gasLimit;\n  }\n  set gasLimit(value) {\n    this.#gasLimit = getBigInt(value);\n  }\n  /**\n   *  The gas price.\n   *\n   *  On legacy networks this defines the fee that will be paid. On\n   *  EIP-1559 networks, this should be ``null``.\n   */\n  get gasPrice() {\n    const value = this.#gasPrice;\n    if (value == null && (this.type === 0 || this.type === 1)) {\n      return BN_0;\n    }\n    return value;\n  }\n  set gasPrice(value) {\n    this.#gasPrice = value == null ? null : getBigInt(value, \"gasPrice\");\n  }\n  /**\n   *  The maximum priority fee per unit of gas to pay. On legacy\n   *  networks this should be ``null``.\n   */\n  get maxPriorityFeePerGas() {\n    const value = this.#maxPriorityFeePerGas;\n    if (value == null) {\n      if (this.type === 2 || this.type === 3) {\n        return BN_0;\n      }\n      return null;\n    }\n    return value;\n  }\n  set maxPriorityFeePerGas(value) {\n    this.#maxPriorityFeePerGas = value == null ? null : getBigInt(value, \"maxPriorityFeePerGas\");\n  }\n  /**\n   *  The maximum total fee per unit of gas to pay. On legacy\n   *  networks this should be ``null``.\n   */\n  get maxFeePerGas() {\n    const value = this.#maxFeePerGas;\n    if (value == null) {\n      if (this.type === 2 || this.type === 3) {\n        return BN_0;\n      }\n      return null;\n    }\n    return value;\n  }\n  set maxFeePerGas(value) {\n    this.#maxFeePerGas = value == null ? null : getBigInt(value, \"maxFeePerGas\");\n  }\n  /**\n   *  The transaction data. For ``init`` transactions this is the\n   *  deployment code.\n   */\n  get data() {\n    return this.#data;\n  }\n  set data(value) {\n    this.#data = hexlify(value);\n  }\n  /**\n   *  The amount of ether (in wei) to send in this transactions.\n   */\n  get value() {\n    return this.#value;\n  }\n  set value(value) {\n    this.#value = getBigInt(value, \"value\");\n  }\n  /**\n   *  The chain ID this transaction is valid on.\n   */\n  get chainId() {\n    return this.#chainId;\n  }\n  set chainId(value) {\n    this.#chainId = getBigInt(value);\n  }\n  /**\n   *  If signed, the signature for this transaction.\n   */\n  get signature() {\n    return this.#sig || null;\n  }\n  set signature(value) {\n    this.#sig = value == null ? null : Signature.from(value);\n  }\n  isValid() {\n    const sig = this.signature;\n    if (sig && !sig.isValid()) {\n      return false;\n    }\n    const auths = this.authorizationList;\n    if (auths) {\n      for (const auth of auths) {\n        if (!auth.signature.isValid()) {\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n  /**\n   *  The access list.\n   *\n   *  An access list permits discounted (but pre-paid) access to\n   *  bytecode and state variable access within contract execution.\n   */\n  get accessList() {\n    const value = this.#accessList || null;\n    if (value == null) {\n      if (this.type === 1 || this.type === 2 || this.type === 3) {\n        // @TODO: in v7, this should assign the value or become\n        // a live object itself, otherwise mutation is inconsistent\n        return [];\n      }\n      return null;\n    }\n    return value;\n  }\n  set accessList(value) {\n    this.#accessList = value == null ? null : accessListify(value);\n  }\n  get authorizationList() {\n    const value = this.#auths || null;\n    if (value == null) {\n      if (this.type === 4) {\n        // @TODO: in v7, this should become a live object itself,\n        // otherwise mutation is inconsistent\n        return [];\n      }\n    }\n    return value;\n  }\n  set authorizationList(auths) {\n    this.#auths = auths == null ? null : auths.map(a => authorizationify(a));\n  }\n  /**\n   *  The max fee per blob gas for Cancun transactions.\n   */\n  get maxFeePerBlobGas() {\n    const value = this.#maxFeePerBlobGas;\n    if (value == null && this.type === 3) {\n      return BN_0;\n    }\n    return value;\n  }\n  set maxFeePerBlobGas(value) {\n    this.#maxFeePerBlobGas = value == null ? null : getBigInt(value, \"maxFeePerBlobGas\");\n  }\n  /**\n   *  The BLOb versioned hashes for Cancun transactions.\n   */\n  get blobVersionedHashes() {\n    // @TODO: Mutation is inconsistent; if unset, the returned value\n    // cannot mutate the object, if set it can\n    let value = this.#blobVersionedHashes;\n    if (value == null && this.type === 3) {\n      return [];\n    }\n    return value;\n  }\n  set blobVersionedHashes(value) {\n    if (value != null) {\n      assertArgument(Array.isArray(value), \"blobVersionedHashes must be an Array\", \"value\", value);\n      value = value.slice();\n      for (let i = 0; i < value.length; i++) {\n        assertArgument(isHexString(value[i], 32), \"invalid blobVersionedHash\", `value[${i}]`, value[i]);\n      }\n    }\n    this.#blobVersionedHashes = value;\n  }\n  /**\n   *  The BLObs for the Transaction, if any.\n   *\n   *  If ``blobs`` is non-``null``, then the [[seriailized]]\n   *  will return the network formatted sidecar, otherwise it\n   *  will return the standard [[link-eip-2718]] payload. The\n   *  [[unsignedSerialized]] is unaffected regardless.\n   *\n   *  When setting ``blobs``, either fully valid [[Blob]] objects\n   *  may be specified (i.e. correctly padded, with correct\n   *  committments and proofs) or a raw [[BytesLike]] may\n   *  be provided.\n   *\n   *  If raw [[BytesLike]] are provided, the [[kzg]] property **must**\n   *  be already set. The blob will be correctly padded and the\n   *  [[KzgLibrary]] will be used to compute the committment and\n   *  proof for the blob.\n   *\n   *  A BLOb is a sequence of field elements, each of which must\n   *  be within the BLS field modulo, so some additional processing\n   *  may be required to encode arbitrary data to ensure each 32 byte\n   *  field is within the valid range.\n   *\n   *  Setting this automatically populates [[blobVersionedHashes]],\n   *  overwriting any existing values. Setting this to ``null``\n   *  does **not** remove the [[blobVersionedHashes]], leaving them\n   *  present.\n   */\n  get blobs() {\n    if (this.#blobs == null) {\n      return null;\n    }\n    return this.#blobs.map(b => Object.assign({}, b));\n  }\n  set blobs(_blobs) {\n    if (_blobs == null) {\n      this.#blobs = null;\n      return;\n    }\n    const blobs = [];\n    const versionedHashes = [];\n    for (let i = 0; i < _blobs.length; i++) {\n      const blob = _blobs[i];\n      if (isBytesLike(blob)) {\n        assert(this.#kzg, \"adding a raw blob requires a KZG library\", \"UNSUPPORTED_OPERATION\", {\n          operation: \"set blobs()\"\n        });\n        let data = getBytes(blob);\n        assertArgument(data.length <= BLOB_SIZE, \"blob is too large\", `blobs[${i}]`, blob);\n        // Pad blob if necessary\n        if (data.length !== BLOB_SIZE) {\n          const padded = new Uint8Array(BLOB_SIZE);\n          padded.set(data);\n          data = padded;\n        }\n        const commit = this.#kzg.blobToKzgCommitment(data);\n        const proof = hexlify(this.#kzg.computeBlobKzgProof(data, commit));\n        blobs.push({\n          data: hexlify(data),\n          commitment: hexlify(commit),\n          proof\n        });\n        versionedHashes.push(getVersionedHash(1, commit));\n      } else {\n        const data = hexlify(blob.data);\n        const commitment = hexlify(blob.commitment);\n        const proof = hexlify(blob.proof);\n        blobs.push({\n          data,\n          commitment,\n          proof\n        });\n        versionedHashes.push(getVersionedHash(1, commitment));\n      }\n    }\n    this.#blobs = blobs;\n    this.#blobVersionedHashes = versionedHashes;\n  }\n  get kzg() {\n    return this.#kzg;\n  }\n  set kzg(kzg) {\n    if (kzg == null) {\n      this.#kzg = null;\n    } else {\n      this.#kzg = getKzgLibrary(kzg);\n    }\n  }\n  get blobWrapperVersion() {\n    return this.#blobWrapperVersion;\n  }\n  set blobWrapperVersion(value) {\n    this.#blobWrapperVersion = value;\n  }\n  /**\n   *  Creates a new Transaction with default values.\n   */\n  constructor() {\n    this.#type = null;\n    this.#to = null;\n    this.#nonce = 0;\n    this.#gasLimit = BN_0;\n    this.#gasPrice = null;\n    this.#maxPriorityFeePerGas = null;\n    this.#maxFeePerGas = null;\n    this.#data = \"0x\";\n    this.#value = BN_0;\n    this.#chainId = BN_0;\n    this.#sig = null;\n    this.#accessList = null;\n    this.#maxFeePerBlobGas = null;\n    this.#blobVersionedHashes = null;\n    this.#kzg = null;\n    this.#blobs = null;\n    this.#auths = null;\n    this.#blobWrapperVersion = null;\n  }\n  /**\n   *  The transaction hash, if signed. Otherwise, ``null``.\n   */\n  get hash() {\n    if (this.signature == null) {\n      return null;\n    }\n    return keccak256(this.#getSerialized(true, false));\n  }\n  /**\n   *  The pre-image hash of this transaction.\n   *\n   *  This is the digest that a [[Signer]] must sign to authorize\n   *  this transaction.\n   */\n  get unsignedHash() {\n    return keccak256(this.unsignedSerialized);\n  }\n  /**\n   *  The sending address, if signed. Otherwise, ``null``.\n   */\n  get from() {\n    if (this.signature == null) {\n      return null;\n    }\n    return recoverAddress(this.unsignedHash, this.signature.getCanonical());\n  }\n  /**\n   *  The public key of the sender, if signed. Otherwise, ``null``.\n   */\n  get fromPublicKey() {\n    if (this.signature == null) {\n      return null;\n    }\n    return SigningKey.recoverPublicKey(this.unsignedHash, this.signature.getCanonical());\n  }\n  /**\n   *  Returns true if signed.\n   *\n   *  This provides a Type Guard that properties requiring a signed\n   *  transaction are non-null.\n   */\n  isSigned() {\n    return this.signature != null;\n  }\n  #getSerialized(signed, sidecar) {\n    assert(!signed || this.signature != null, \"cannot serialize unsigned transaction; maybe you meant .unsignedSerialized\", \"UNSUPPORTED_OPERATION\", {\n      operation: \".serialized\"\n    });\n    const sig = signed ? this.signature : null;\n    switch (this.inferType()) {\n      case 0:\n        return _serializeLegacy(this, sig);\n      case 1:\n        return _serializeEip2930(this, sig);\n      case 2:\n        return _serializeEip1559(this, sig);\n      case 3:\n        return _serializeEip4844(this, sig, sidecar ? this.blobs : null);\n      case 4:\n        return _serializeEip7702(this, sig);\n    }\n    assert(false, \"unsupported transaction type\", \"UNSUPPORTED_OPERATION\", {\n      operation: \".serialized\"\n    });\n  }\n  /**\n   *  The serialized transaction.\n   *\n   *  This throws if the transaction is unsigned. For the pre-image,\n   *  use [[unsignedSerialized]].\n   */\n  get serialized() {\n    return this.#getSerialized(true, true);\n  }\n  /**\n   *  The transaction pre-image.\n   *\n   *  The hash of this is the digest which needs to be signed to\n   *  authorize this transaction.\n   */\n  get unsignedSerialized() {\n    return this.#getSerialized(false, false);\n  }\n  /**\n   *  Return the most \"likely\" type; currently the highest\n   *  supported transaction type.\n   */\n  inferType() {\n    const types = this.inferTypes();\n    // Prefer London (EIP-1559) over Cancun (BLOb)\n    if (types.indexOf(2) >= 0) {\n      return 2;\n    }\n    // Return the highest inferred type\n    return types.pop();\n  }\n  /**\n   *  Validates the explicit properties and returns a list of compatible\n   *  transaction types.\n   */\n  inferTypes() {\n    // Checks that there are no conflicting properties set\n    const hasGasPrice = this.gasPrice != null;\n    const hasFee = this.maxFeePerGas != null || this.maxPriorityFeePerGas != null;\n    const hasAccessList = this.accessList != null;\n    const hasBlob = this.#maxFeePerBlobGas != null || this.#blobVersionedHashes;\n    //if (hasGasPrice && hasFee) {\n    //    throw new Error(\"transaction cannot have gasPrice and maxFeePerGas\");\n    //}\n    if (this.maxFeePerGas != null && this.maxPriorityFeePerGas != null) {\n      assert(this.maxFeePerGas >= this.maxPriorityFeePerGas, \"priorityFee cannot be more than maxFee\", \"BAD_DATA\", {\n        value: this\n      });\n    }\n    //if (this.type === 2 && hasGasPrice) {\n    //    throw new Error(\"eip-1559 transaction cannot have gasPrice\");\n    //}\n    assert(!hasFee || this.type !== 0 && this.type !== 1, \"transaction type cannot have maxFeePerGas or maxPriorityFeePerGas\", \"BAD_DATA\", {\n      value: this\n    });\n    assert(this.type !== 0 || !hasAccessList, \"legacy transaction cannot have accessList\", \"BAD_DATA\", {\n      value: this\n    });\n    const types = [];\n    // Explicit type\n    if (this.type != null) {\n      types.push(this.type);\n    } else {\n      if (this.authorizationList && this.authorizationList.length) {\n        types.push(4);\n      } else if (hasFee) {\n        types.push(2);\n      } else if (hasGasPrice) {\n        types.push(1);\n        if (!hasAccessList) {\n          types.push(0);\n        }\n      } else if (hasAccessList) {\n        types.push(1);\n        types.push(2);\n      } else if (hasBlob && this.to) {\n        types.push(3);\n      } else {\n        types.push(0);\n        types.push(1);\n        types.push(2);\n        types.push(3);\n      }\n    }\n    types.sort();\n    return types;\n  }\n  /**\n   *  Returns true if this transaction is a legacy transaction (i.e.\n   *  ``type === 0``).\n   *\n   *  This provides a Type Guard that the related properties are\n   *  non-null.\n   */\n  isLegacy() {\n    return this.type === 0;\n  }\n  /**\n   *  Returns true if this transaction is berlin hardform transaction (i.e.\n   *  ``type === 1``).\n   *\n   *  This provides a Type Guard that the related properties are\n   *  non-null.\n   */\n  isBerlin() {\n    return this.type === 1;\n  }\n  /**\n   *  Returns true if this transaction is london hardform transaction (i.e.\n   *  ``type === 2``).\n   *\n   *  This provides a Type Guard that the related properties are\n   *  non-null.\n   */\n  isLondon() {\n    return this.type === 2;\n  }\n  /**\n   *  Returns true if this transaction is an [[link-eip-4844]] BLOB\n   *  transaction.\n   *\n   *  This provides a Type Guard that the related properties are\n   *  non-null.\n   */\n  isCancun() {\n    return this.type === 3;\n  }\n  /**\n   *  Create a copy of this transaciton.\n   */\n  clone() {\n    return Transaction.from(this);\n  }\n  /**\n   *  Return a JSON-friendly object.\n   */\n  toJSON() {\n    const s = v => {\n      if (v == null) {\n        return null;\n      }\n      return v.toString();\n    };\n    return {\n      type: this.type,\n      to: this.to,\n      //            from: this.from,\n      data: this.data,\n      nonce: this.nonce,\n      gasLimit: s(this.gasLimit),\n      gasPrice: s(this.gasPrice),\n      maxPriorityFeePerGas: s(this.maxPriorityFeePerGas),\n      maxFeePerGas: s(this.maxFeePerGas),\n      value: s(this.value),\n      chainId: s(this.chainId),\n      sig: this.signature ? this.signature.toJSON() : null,\n      accessList: this.accessList\n    };\n  }\n  [inspect]() {\n    return this.toString();\n  }\n  toString() {\n    const output = [];\n    const add = key => {\n      let value = this[key];\n      if (typeof value === \"string\") {\n        value = JSON.stringify(value);\n      }\n      output.push(`${key}: ${value}`);\n    };\n    if (this.type) {\n      add(\"type\");\n    }\n    add(\"to\");\n    add(\"data\");\n    add(\"nonce\");\n    add(\"gasLimit\");\n    add(\"value\");\n    if (this.chainId != null) {\n      add(\"chainId\");\n    }\n    if (this.signature) {\n      add(\"from\");\n      output.push(`signature: ${this.signature.toString()}`);\n    }\n    // @TODO: accessList\n    // @TODO: blobs (might make output huge; maybe just include a flag?)\n    const auths = this.authorizationList;\n    if (auths) {\n      const outputAuths = [];\n      for (const auth of auths) {\n        const o = [];\n        o.push(`address: ${JSON.stringify(auth.address)}`);\n        if (auth.nonce != null) {\n          o.push(`nonce: ${auth.nonce}`);\n        }\n        if (auth.chainId != null) {\n          o.push(`chainId: ${auth.chainId}`);\n        }\n        if (auth.signature) {\n          o.push(`signature: ${auth.signature.toString()}`);\n        }\n        outputAuths.push(`Authorization { ${o.join(\", \")} }`);\n      }\n      output.push(`authorizations: [ ${outputAuths.join(\", \")} ]`);\n    }\n    return `Transaction { ${output.join(\", \")} }`;\n  }\n  /**\n   *  Create a **Transaction** from a serialized transaction or a\n   *  Transaction-like object.\n   */\n  static from(tx) {\n    if (tx == null) {\n      return new Transaction();\n    }\n    if (typeof tx === \"string\") {\n      const payload = getBytes(tx);\n      if (payload[0] >= 0x7f) {\n        // @TODO: > vs >= ??\n        return Transaction.from(_parseLegacy(payload));\n      }\n      switch (payload[0]) {\n        case 1:\n          return Transaction.from(_parseEip2930(payload));\n        case 2:\n          return Transaction.from(_parseEip1559(payload));\n        case 3:\n          return Transaction.from(_parseEip4844(payload));\n        case 4:\n          return Transaction.from(_parseEip7702(payload));\n      }\n      assert(false, \"unsupported transaction type\", \"UNSUPPORTED_OPERATION\", {\n        operation: \"from\"\n      });\n    }\n    const result = new Transaction();\n    if (tx.type != null) {\n      result.type = tx.type;\n    }\n    if (tx.to != null) {\n      result.to = tx.to;\n    }\n    if (tx.nonce != null) {\n      result.nonce = tx.nonce;\n    }\n    if (tx.gasLimit != null) {\n      result.gasLimit = tx.gasLimit;\n    }\n    if (tx.gasPrice != null) {\n      result.gasPrice = tx.gasPrice;\n    }\n    if (tx.maxPriorityFeePerGas != null) {\n      result.maxPriorityFeePerGas = tx.maxPriorityFeePerGas;\n    }\n    if (tx.maxFeePerGas != null) {\n      result.maxFeePerGas = tx.maxFeePerGas;\n    }\n    if (tx.maxFeePerBlobGas != null) {\n      result.maxFeePerBlobGas = tx.maxFeePerBlobGas;\n    }\n    if (tx.data != null) {\n      result.data = tx.data;\n    }\n    if (tx.value != null) {\n      result.value = tx.value;\n    }\n    if (tx.chainId != null) {\n      result.chainId = tx.chainId;\n    }\n    if (tx.signature != null) {\n      result.signature = Signature.from(tx.signature);\n    }\n    if (tx.accessList != null) {\n      result.accessList = tx.accessList;\n    }\n    if (tx.authorizationList != null) {\n      result.authorizationList = tx.authorizationList;\n    }\n    // This will get overwritten by blobs, if present\n    if (tx.blobVersionedHashes != null) {\n      result.blobVersionedHashes = tx.blobVersionedHashes;\n    }\n    // Make sure we assign the kzg before assigning blobs, which\n    // require the library in the event raw blob data is provided.\n    if (tx.kzg != null) {\n      result.kzg = tx.kzg;\n    }\n    if (tx.blobWrapperVersion != null) {\n      result.blobWrapperVersion = tx.blobWrapperVersion;\n    }\n    if (tx.blobs != null) {\n      result.blobs = tx.blobs;\n    }\n    if (tx.hash != null) {\n      assertArgument(result.isSigned(), \"unsigned transaction cannot define '.hash'\", \"tx\", tx);\n      assertArgument(result.hash === tx.hash, \"hash mismatch\", \"tx\", tx);\n    }\n    if (tx.from != null) {\n      assertArgument(result.isSigned(), \"unsigned transaction cannot define '.from'\", \"tx\", tx);\n      assertArgument(result.from.toLowerCase() === (tx.from || \"\").toLowerCase(), \"from mismatch\", \"tx\", tx);\n    }\n    return result;\n  }\n}","map":{"version":3,"names":["getAddress","ZeroAddress","keccak256","sha256","Signature","SigningKey","concat","decodeRlp","encodeRlp","getBytes","getBigInt","getNumber","hexlify","assert","assertArgument","isBytesLike","isHexString","toBeArray","zeroPadValue","accessListify","authorizationify","recoverAddress","BN_0","BigInt","BN_2","BN_27","BN_28","BN_35","BN_MAX_UINT","inspect","Symbol","for","BLOB_SIZE","CELL_COUNT","splitBlobCells","_proof","cellCount","cellProofs","proof","cellSize","length","i","push","subarray","getKzgLibrary","kzg","blobToKzgCommitment","blob","blobToKZGCommitment","computeBlobKzgProof","commitment","computeBlobProof","computeBlobKZGProof","getVersionedHash","version","hash","versioned","toString","substring","handleAddress","value","handleAccessList","param","error","message","handleAuthorizationList","Array","isArray","Error","result","auth","address","nonce","handleUint","chainId","signature","from","yParity","handleNumber","r","s","_value","formatNumber","name","formatAccessList","map","set","storageKeys","formatAuthorizationList","a","_s","formatHashes","_parseLegacy","data","fields","tx","type","gasPrice","gasLimit","to","v","_serializeLegacy","sig","networkV","legacyChainId","legacy","getChainIdV","_parseEipSignature","_parseEip1559","slice","maxPriorityFeePerGas","maxFeePerGas","accessList","_serializeEip1559","_parseEip2930","_serializeEip2930","_parseEip4844","typeName","blobWrapperVersion","blobs","fBlobs","fCommits","fProofs","j","maxFeePerBlobGas","blobVersionedHashes","_serializeEip4844","wrapperVersion","p","b","_parseEip7702","authorizationList","_serializeEip7702","Transaction","auths","isValid","Object","assign","_blobs","versionedHashes","operation","padded","Uint8Array","commit","constructor","getSerialized","unsignedHash","unsignedSerialized","getCanonical","fromPublicKey","recoverPublicKey","isSigned","#getSerialized","signed","sidecar","inferType","serialized","types","inferTypes","indexOf","pop","hasGasPrice","hasFee","hasAccessList","hasBlob","sort","isLegacy","isBerlin","isLondon","isCancun","clone","toJSON","output","add","key","JSON","stringify","outputAuths","o","join","payload","toLowerCase"],"sources":["/Users/wocten/Documents/blockchain_hocbongthongminh/project-root/frontend/node_modules/ethers/src.ts/transaction/transaction.ts"],"sourcesContent":["\nimport { getAddress } from \"../address/index.js\";\nimport { ZeroAddress } from \"../constants/addresses.js\";\nimport {\n    keccak256, sha256, Signature, SigningKey\n} from \"../crypto/index.js\";\nimport {\n    concat, decodeRlp, encodeRlp, getBytes, getBigInt, getNumber, hexlify,\n    assert, assertArgument, isBytesLike, isHexString, toBeArray, zeroPadValue\n} from \"../utils/index.js\";\n\nimport { accessListify } from \"./accesslist.js\";\nimport { authorizationify } from \"./authorization.js\";\nimport { recoverAddress } from \"./address.js\";\n\nimport type { BigNumberish, BytesLike } from \"../utils/index.js\";\nimport type { SignatureLike } from \"../crypto/index.js\";\n\nimport type {\n    AccessList, AccessListish, Authorization, AuthorizationLike\n} from \"./index.js\";\n\nconst BN_0 = BigInt(0);\nconst BN_2 = BigInt(2);\nconst BN_27 = BigInt(27)\nconst BN_28 = BigInt(28)\nconst BN_35 = BigInt(35);\nconst BN_MAX_UINT = BigInt(\"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\");\n\nconst inspect = Symbol.for(\"nodejs.util.inspect.custom\");\n\nconst BLOB_SIZE = 4096 * 32;\nconst CELL_COUNT = 128;\n\n\n/**\n *  Returns a BLOb proof as its cells for [[link-eip-7594]] BLOb.\n *\n *  The default %%cellCount%% is 128.\n */\nexport function splitBlobCells(_proof: BytesLike, cellCount?: number): Array<string> {\n    if (cellCount == null) { cellCount = CELL_COUNT; }\n\n    const cellProofs: Array<string> = [ ];\n    const proof = getBytes(_proof);\n\n    const cellSize = proof.length / cellCount;\n    for (let i = 0; i < proof.length; i += cellSize) {\n        cellProofs.push(hexlify(proof.subarray(i, i + cellSize)));\n    }\n\n    return cellProofs;\n}\n\n// The BLS Modulo; each field within a BLOb must be less than this\n//const BLOB_BLS_MODULO = BigInt(\"0x73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001\");\n\n/**\n *  A **TransactionLike** is an object which is appropriate as a loose\n *  input for many operations which will populate missing properties of\n *  a transaction.\n */\nexport interface TransactionLike<A = string> {\n    /**\n     *  The type.\n     */\n    type?: null | number;\n\n    /**\n     *  The recipient address or ``null`` for an ``init`` transaction.\n     */\n    to?: null | A;\n\n    /**\n     *  The sender.\n     */\n    from?: null | A;\n\n    /**\n     *  The nonce.\n     */\n    nonce?: null | number;\n\n    /**\n     *  The maximum amount of gas that can be used.\n     */\n    gasLimit?: null | BigNumberish;\n\n    /**\n     *  The gas price for legacy and berlin transactions.\n     */\n    gasPrice?: null | BigNumberish;\n\n    /**\n     *  The maximum priority fee per gas for london transactions.\n     */\n    maxPriorityFeePerGas?: null | BigNumberish;\n\n    /**\n     *  The maximum total fee per gas for london transactions.\n     */\n    maxFeePerGas?: null | BigNumberish;\n\n    /**\n     *  The data.\n     */\n    data?: null | string;\n\n    /**\n     *  The value (in wei) to send.\n     */\n    value?: null | BigNumberish;\n\n    /**\n     *  The chain ID the transaction is valid on.\n     */\n    chainId?: null | BigNumberish;\n\n    /**\n     *  The transaction hash.\n     */\n    hash?: null | string;\n\n    /**\n     *  The signature provided by the sender.\n     */\n    signature?: null | SignatureLike;\n\n    /**\n     *  The access list for berlin and london transactions.\n     */\n    accessList?: null | AccessListish;\n\n    /**\n     *  The maximum fee per blob gas (see [[link-eip-4844]]).\n     */\n    maxFeePerBlobGas?: null | BigNumberish;\n\n    /**\n     *  The versioned hashes (see [[link-eip-4844]]).\n     */\n    blobVersionedHashes?: null | Array<string>;\n\n    /**\n     *  The blobs (if any) attached to this transaction (see [[link-eip-4844]]).\n     */\n    blobs?: null | Array<BlobLike>\n\n    /**\n     *  An external library for computing the KZG commitments and\n     *  proofs necessary for EIP-4844 transactions (see [[link-eip-4844]]).\n     *\n     *  This is generally ``null``, unless you are creating BLOb\n     *  transactions.\n     */\n    kzg?: null | KzgLibraryLike;\n\n    /**\n     *  The [[link-eip-7594]] BLOb Wrapper Version used for PeerDAS.\n     *\n     *  For networks that use EIP-7594, this property is required to\n     *  serialize the sidecar correctly.\n     */\n    blobWrapperVersion?: null | number;\n\n    /**\n     *  The [[link-eip-7702]] authorizations (if any).\n     */\n    authorizationList?: null | Array<Authorization>;\n}\n\n/**\n *  A full-valid BLOb object for [[link-eip-4844]] transactions.\n *\n *  The commitment and proof should have been computed using a\n *  KZG library.\n */\nexport interface Blob {\n    /**\n     *  The blob data.\n     */\n    data: string;\n\n    /**\n     * A EIP-4844 BLOb uses a string proof, while EIP-7594 use an\n     * array of strings representing the cells of the proof.\n     */\n    proof: string;\n\n    /**\n     *  The BLOb commitment.\n     */\n    commitment: string;\n}\n\n/**\n *  A BLOb object that can be passed for [[link-eip-4844]]\n *  transactions.\n *\n *  It may have had its commitment and proof already provided\n *  or rely on an attached [[KzgLibrary]] to compute them.\n */\nexport type BlobLike = BytesLike | {\n    data: BytesLike;\n    proof: BytesLike;\n    commitment: BytesLike;\n};\n\n/**\n *  A KZG Library with the necessary functions to compute\n *  BLOb commitments and proofs.\n */\nexport interface KzgLibrary {\n    blobToKzgCommitment: (blob: Uint8Array) => Uint8Array;\n    computeBlobKzgProof: (blob: Uint8Array, commitment: Uint8Array) => Uint8Array;\n}\n\n/**\n *  A KZG Library with any of the various API configurations.\n *  As the library is still experimental and the API is not\n *  stable, depending on the version used the method names and\n *  signatures are still in flux.\n *\n *  This allows any of the versions to be passed into Transaction\n *  while providing a stable external API.\n */\nexport type KzgLibraryLike  = KzgLibrary | {\n    // kzg-wasm >= 0.5.0\n    blobToKZGCommitment: (blob: string) => string;\n    computeBlobKZGProof: (blob: string, commitment: string) => string;\n} | {\n    // micro-ecc-signer\n    blobToKzgCommitment: (blob: string) => string | Uint8Array;\n    computeBlobProof: (blob: string, commitment: string) => string | Uint8Array;\n};\n\nfunction getKzgLibrary(kzg: KzgLibraryLike): KzgLibrary {\n\n    const blobToKzgCommitment = (blob: Uint8Array) => {\n\n        if (\"computeBlobProof\" in kzg) {\n            // micro-ecc-signer; check for computeBlobProof since this API\n            // expects a string while the kzg-wasm below expects a Unit8Array\n\n            if (\"blobToKzgCommitment\" in kzg && typeof(kzg.blobToKzgCommitment) === \"function\") {\n                return getBytes(kzg.blobToKzgCommitment(hexlify(blob)))\n            }\n\n        } else if (\"blobToKzgCommitment\" in kzg && typeof(kzg.blobToKzgCommitment) === \"function\") {\n            // kzg-wasm <0.5.0; blobToKzgCommitment(Uint8Array) => Uint8Array\n\n            return getBytes(kzg.blobToKzgCommitment(blob));\n        }\n\n        // kzg-wasm >= 0.5.0; blobToKZGCommitment(string) => string\n        if (\"blobToKZGCommitment\" in kzg && typeof(kzg.blobToKZGCommitment) === \"function\") {\n            return getBytes(kzg.blobToKZGCommitment(hexlify(blob)));\n        }\n\n        assertArgument(false, \"unsupported KZG library\", \"kzg\", kzg);\n    };\n\n    const computeBlobKzgProof = (blob: Uint8Array, commitment: Uint8Array) => {\n\n        // micro-ecc-signer\n        if (\"computeBlobProof\" in kzg && typeof(kzg.computeBlobProof) === \"function\") {\n            return getBytes(kzg.computeBlobProof(hexlify(blob), hexlify(commitment)))\n        }\n\n        // kzg-wasm <0.5.0; computeBlobKzgProof(Uint8Array, Uint8Array) => Uint8Array\n        if (\"computeBlobKzgProof\" in kzg && typeof(kzg.computeBlobKzgProof) === \"function\") {\n            return kzg.computeBlobKzgProof(blob, commitment);\n        }\n\n        // kzg-wasm >= 0.5.0; computeBlobKZGProof(string, string) => string\n        if (\"computeBlobKZGProof\" in kzg && typeof(kzg.computeBlobKZGProof) === \"function\") {\n            return getBytes(kzg.computeBlobKZGProof(hexlify(blob), hexlify(commitment)));\n        }\n\n        assertArgument(false, \"unsupported KZG library\", \"kzg\", kzg);\n    };\n\n    return { blobToKzgCommitment, computeBlobKzgProof };\n}\n\nfunction getVersionedHash(version: number, hash: BytesLike): string {\n    let versioned = version.toString(16);\n    while (versioned.length < 2) { versioned = \"0\" + versioned; }\n    versioned += sha256(hash).substring(4);\n    return \"0x\" + versioned;\n}\n\nfunction handleAddress(value: string): null | string {\n    if (value === \"0x\") { return null; }\n    return getAddress(value);\n}\n\nfunction handleAccessList(value: any, param: string): AccessList {\n    try {\n        return accessListify(value);\n    } catch (error: any) {\n        assertArgument(false, error.message, param, value);\n    }\n}\n\nfunction handleAuthorizationList(value: any, param: string): Array<Authorization> {\n    try {\n        if (!Array.isArray(value)) { throw new Error(\"authorizationList: invalid array\"); }\n        const result: Array<Authorization> = [ ];\n        for (let i = 0; i < value.length; i++) {\n            const auth: Array<string> = value[i];\n            if (!Array.isArray(auth)) { throw new Error(`authorization[${ i }]: invalid array`); }\n            if (auth.length !== 6) { throw new Error(`authorization[${ i }]: wrong length`); }\n            if (!auth[1]) { throw new Error(`authorization[${ i }]: null address`); }\n            result.push({\n                address: <string>handleAddress(auth[1]),\n                nonce: handleUint(auth[2], \"nonce\"),\n                chainId: handleUint(auth[0], \"chainId\"),\n                signature: Signature.from({\n                    yParity: <0 | 1>handleNumber(auth[3], \"yParity\"),\n                    r: zeroPadValue(auth[4], 32),\n                    s: zeroPadValue(auth[5], 32)\n                })\n            });\n        }\n        return result;\n    } catch (error: any) {\n        assertArgument(false, error.message, param, value);\n    }\n}\n\nfunction handleNumber(_value: string, param: string): number {\n    if (_value === \"0x\") { return 0; }\n    return getNumber(_value, param);\n}\n\nfunction handleUint(_value: string, param: string): bigint {\n    if (_value === \"0x\") { return BN_0; }\n    const value = getBigInt(_value, param);\n    assertArgument(value <= BN_MAX_UINT, \"value exceeds uint size\", param, value);\n    return value;\n}\n\nfunction formatNumber(_value: BigNumberish, name: string): Uint8Array {\n    const value = getBigInt(_value, \"value\");\n    const result = toBeArray(value);\n    assertArgument(result.length <= 32, `value too large`, `tx.${ name }`, value);\n    return result;\n}\n\nfunction formatAccessList(value: AccessListish): Array<[ string, Array<string> ]> {\n    return accessListify(value).map((set) => [ set.address, set.storageKeys ]);\n}\n\nfunction formatAuthorizationList(value: Array<Authorization>): Array<Array<string | Uint8Array>> {\n    return value.map((a) => {\n        return [\n            formatNumber(a.chainId, \"chainId\"),\n            a.address,\n            formatNumber(a.nonce, \"nonce\"),\n            formatNumber(a.signature.yParity, \"yParity\"),\n            toBeArray(a.signature.r),\n            toBeArray(a.signature._s)\n        ];\n    });\n}\n\nfunction formatHashes(value: Array<string>, param: string): Array<string> {\n    assertArgument(Array.isArray(value), `invalid ${ param }`, \"value\", value);\n    for (let i = 0; i < value.length; i++) {\n        assertArgument(isHexString(value[i], 32), \"invalid ${ param } hash\", `value[${ i }]`, value[i]);\n    }\n    return value;\n}\n\nfunction _parseLegacy(data: Uint8Array): TransactionLike {\n    const fields: any = decodeRlp(data);\n\n    assertArgument(Array.isArray(fields) && (fields.length === 9 || fields.length === 6),\n        \"invalid field count for legacy transaction\", \"data\", data);\n\n    const tx: TransactionLike = {\n        type:     0,\n        nonce:    handleNumber(fields[0], \"nonce\"),\n        gasPrice: handleUint(fields[1], \"gasPrice\"),\n        gasLimit: handleUint(fields[2], \"gasLimit\"),\n        to:       handleAddress(fields[3]),\n        value:    handleUint(fields[4], \"value\"),\n        data:     hexlify(fields[5]),\n        chainId:  BN_0\n    };\n\n    // Legacy unsigned transaction\n    if (fields.length === 6) { return tx; }\n\n    const v = handleUint(fields[6], \"v\");\n    const r = handleUint(fields[7], \"r\");\n    const s = handleUint(fields[8], \"s\");\n\n    if (r === BN_0 && s === BN_0) {\n        // EIP-155 unsigned transaction\n        tx.chainId = v;\n\n    } else {\n\n        // Compute the EIP-155 chain ID (or 0 for legacy)\n        let chainId = (v - BN_35) / BN_2;\n        if (chainId < BN_0) { chainId = BN_0; }\n        tx.chainId = chainId\n\n        // Signed Legacy Transaction\n        assertArgument(chainId !== BN_0 || (v === BN_27 || v === BN_28), \"non-canonical legacy v\", \"v\", fields[6]);\n\n        tx.signature = Signature.from({\n            r: zeroPadValue(fields[7], 32),\n            s: zeroPadValue(fields[8], 32),\n            v\n        });\n\n        //tx.hash = keccak256(data);\n    }\n\n    return tx;\n}\n\nfunction _serializeLegacy(tx: Transaction, sig: null | Signature): string {\n    const fields: Array<any> = [\n        formatNumber(tx.nonce, \"nonce\"),\n        formatNumber(tx.gasPrice || 0, \"gasPrice\"),\n        formatNumber(tx.gasLimit, \"gasLimit\"),\n        (tx.to || \"0x\"),\n        formatNumber(tx.value, \"value\"),\n        tx.data,\n    ];\n\n    let chainId = BN_0;\n    if (tx.chainId != BN_0) {\n        // A chainId was provided; if non-zero we'll use EIP-155\n        chainId = getBigInt(tx.chainId, \"tx.chainId\");\n\n        // We have a chainId in the tx and an EIP-155 v in the signature,\n        // make sure they agree with each other\n        assertArgument(!sig || sig.networkV == null || sig.legacyChainId === chainId,\n             \"tx.chainId/sig.v mismatch\", \"sig\", sig);\n\n    } else if (tx.signature) {\n        // No explicit chainId, but EIP-155 have a derived implicit chainId\n        const legacy = tx.signature.legacyChainId;\n        if (legacy != null) { chainId = legacy; }\n    }\n\n    // Requesting an unsigned transaction\n    if (!sig) {\n        // We have an EIP-155 transaction (chainId was specified and non-zero)\n        if (chainId !== BN_0) {\n            fields.push(toBeArray(chainId));\n            fields.push(\"0x\");\n            fields.push(\"0x\");\n        }\n\n        return encodeRlp(fields);\n    }\n\n    // @TODO: We should probably check that tx.signature, chainId, and sig\n    //        match but that logic could break existing code, so schedule\n    //        this for the next major bump.\n\n    // Compute the EIP-155 v\n    let v = BigInt(27 + sig.yParity);\n    if (chainId !== BN_0) {\n        v = Signature.getChainIdV(chainId, sig.v);\n    } else if (BigInt(sig.v) !== v) {\n        assertArgument(false, \"tx.chainId/sig.v mismatch\", \"sig\", sig);\n    }\n\n    // Add the signature\n    fields.push(toBeArray(v));\n    fields.push(toBeArray(sig.r));\n    fields.push(toBeArray(sig._s));\n\n    return encodeRlp(fields);\n}\n\nfunction _parseEipSignature(tx: TransactionLike, fields: Array<string>): void {\n    let yParity: number;\n    try {\n        yParity = handleNumber(fields[0], \"yParity\");\n        if (yParity !== 0 && yParity !== 1) { throw new Error(\"bad yParity\"); }\n    } catch (error) {\n        assertArgument(false, \"invalid yParity\", \"yParity\", fields[0]);\n    }\n\n    const r = zeroPadValue(fields[1], 32);\n    const s = zeroPadValue(fields[2], 32);\n\n    const signature = Signature.from({ r, s, yParity });\n    tx.signature = signature;\n}\n\nfunction _parseEip1559(data: Uint8Array): TransactionLike {\n    const fields: any = decodeRlp(getBytes(data).slice(1));\n\n    assertArgument(Array.isArray(fields) && (fields.length === 9 || fields.length === 12),\n        \"invalid field count for transaction type: 2\", \"data\", hexlify(data));\n\n    const tx: TransactionLike = {\n        type:                  2,\n        chainId:               handleUint(fields[0], \"chainId\"),\n        nonce:                 handleNumber(fields[1], \"nonce\"),\n        maxPriorityFeePerGas:  handleUint(fields[2], \"maxPriorityFeePerGas\"),\n        maxFeePerGas:          handleUint(fields[3], \"maxFeePerGas\"),\n        gasPrice:              null,\n        gasLimit:              handleUint(fields[4], \"gasLimit\"),\n        to:                    handleAddress(fields[5]),\n        value:                 handleUint(fields[6], \"value\"),\n        data:                  hexlify(fields[7]),\n        accessList:            handleAccessList(fields[8], \"accessList\"),\n    };\n\n    // Unsigned EIP-1559 Transaction\n    if (fields.length === 9) { return tx; }\n\n    //tx.hash = keccak256(data);\n\n    _parseEipSignature(tx, fields.slice(9));\n\n    return tx;\n}\n\nfunction _serializeEip1559(tx: Transaction, sig: null | Signature): string {\n    const fields: Array<any> = [\n        formatNumber(tx.chainId, \"chainId\"),\n        formatNumber(tx.nonce, \"nonce\"),\n        formatNumber(tx.maxPriorityFeePerGas || 0, \"maxPriorityFeePerGas\"),\n        formatNumber(tx.maxFeePerGas || 0, \"maxFeePerGas\"),\n        formatNumber(tx.gasLimit, \"gasLimit\"),\n        (tx.to || \"0x\"),\n        formatNumber(tx.value, \"value\"),\n        tx.data,\n        formatAccessList(tx.accessList || [ ])\n    ];\n\n    if (sig) {\n        fields.push(formatNumber(sig.yParity, \"yParity\"));\n        fields.push(toBeArray(sig.r));\n        fields.push(toBeArray(sig.s));\n    }\n\n    return concat([ \"0x02\", encodeRlp(fields)]);\n}\n\nfunction _parseEip2930(data: Uint8Array): TransactionLike {\n    const fields: any = decodeRlp(getBytes(data).slice(1));\n\n    assertArgument(Array.isArray(fields) && (fields.length === 8 || fields.length === 11),\n        \"invalid field count for transaction type: 1\", \"data\", hexlify(data));\n\n    const tx: TransactionLike = {\n        type:       1,\n        chainId:    handleUint(fields[0], \"chainId\"),\n        nonce:      handleNumber(fields[1], \"nonce\"),\n        gasPrice:   handleUint(fields[2], \"gasPrice\"),\n        gasLimit:   handleUint(fields[3], \"gasLimit\"),\n        to:         handleAddress(fields[4]),\n        value:      handleUint(fields[5], \"value\"),\n        data:       hexlify(fields[6]),\n        accessList: handleAccessList(fields[7], \"accessList\")\n    };\n\n    // Unsigned EIP-2930 Transaction\n    if (fields.length === 8) { return tx; }\n\n    //tx.hash = keccak256(data);\n\n    _parseEipSignature(tx, fields.slice(8));\n\n    return tx;\n}\n\nfunction _serializeEip2930(tx: Transaction, sig: null | Signature): string {\n    const fields: any = [\n        formatNumber(tx.chainId, \"chainId\"),\n        formatNumber(tx.nonce, \"nonce\"),\n        formatNumber(tx.gasPrice || 0, \"gasPrice\"),\n        formatNumber(tx.gasLimit, \"gasLimit\"),\n        (tx.to || \"0x\"),\n        formatNumber(tx.value, \"value\"),\n        tx.data,\n        formatAccessList(tx.accessList || [ ])\n    ];\n\n    if (sig) {\n        fields.push(formatNumber(sig.yParity, \"recoveryParam\"));\n        fields.push(toBeArray(sig.r));\n        fields.push(toBeArray(sig.s));\n    }\n\n    return concat([ \"0x01\", encodeRlp(fields)]);\n}\n\nfunction _parseEip4844(data: Uint8Array): TransactionLike {\n    let fields: any = decodeRlp(getBytes(data).slice(1));\n\n    let typeName = \"3\";\n\n    let blobWrapperVersion: null | number = null;\n\n    let blobs: null | Array<Blob> = null;\n\n    // Parse the network format\n    if (fields.length === 4 && Array.isArray(fields[0])) {\n        // EIP-4844 format with sidecar\n\n        typeName = \"3 (network format)\";\n\n        const fBlobs = fields[1], fCommits = fields[2], fProofs = fields[3];\n        assertArgument(Array.isArray(fBlobs), \"invalid network format: blobs not an array\", \"fields[1]\", fBlobs);\n        assertArgument(Array.isArray(fCommits), \"invalid network format: commitments not an array\", \"fields[2]\", fCommits);\n        assertArgument(Array.isArray(fProofs), \"invalid network format: proofs not an array\", \"fields[3]\", fProofs);\n        assertArgument(fBlobs.length === fCommits.length, \"invalid network format: blobs/commitments length mismatch\", \"fields\", fields);\n        assertArgument(fBlobs.length === fProofs.length, \"invalid network format: blobs/proofs length mismatch\", \"fields\", fields);\n\n        blobs = [ ];\n        for (let i = 0; i < fields[1].length; i++) {\n            blobs.push({\n                data: fBlobs[i],\n                commitment: fCommits[i],\n                proof: fProofs[i],\n            });\n        }\n\n        fields = fields[0];\n\n    } else if (fields.length === 5 && Array.isArray(fields[0])) {\n        // EIP-7594 format with sidecar\n\n        typeName = \"3 (EIP-7594 network format)\";\n\n        blobWrapperVersion = getNumber(fields[1]);\n        const fBlobs = fields[2], fCommits = fields[3], fProofs = fields[4];\n\n        assertArgument(blobWrapperVersion === 1, `unsupported EIP-7594 network format version: ${ blobWrapperVersion }`, \"fields[1]\", blobWrapperVersion);\n        assertArgument(Array.isArray(fBlobs), \"invalid EIP-7594 network format: blobs not an array\", \"fields[2]\", fBlobs);\n        assertArgument(Array.isArray(fCommits), \"invalid EIP-7594 network format: commitments not an array\", \"fields[3]\", fCommits);\n        assertArgument(Array.isArray(fProofs), \"invalid EIP-7594 network format: proofs not an array\", \"fields[4]\", fProofs);\n        assertArgument(fBlobs.length === fCommits.length, \"invalid network format: blobs/commitments length mismatch\", \"fields\", fields);\n        assertArgument(fBlobs.length * CELL_COUNT === fProofs.length, \"invalid network format: blobs/proofs length mismatch\", \"fields\", fields);\n\n        blobs = [ ];\n        for (let i = 0; i < fBlobs.length; i++) {\n            const proof = [ ];\n            for (let j = 0; j < CELL_COUNT; j++) {\n                proof.push(fProofs[(i * CELL_COUNT) + j]);\n            }\n\n            blobs.push({\n                data: fBlobs[i],\n                commitment: fCommits[i],\n                proof: concat(proof)\n            });\n        }\n\n        fields = fields[0];\n    }\n\n    assertArgument(Array.isArray(fields) && (fields.length === 11 || fields.length === 14),\n        `invalid field count for transaction type: ${ typeName }`, \"data\", hexlify(data));\n\n    const tx: TransactionLike = {\n        type:                  3,\n        chainId:               handleUint(fields[0], \"chainId\"),\n        nonce:                 handleNumber(fields[1], \"nonce\"),\n        maxPriorityFeePerGas:  handleUint(fields[2], \"maxPriorityFeePerGas\"),\n        maxFeePerGas:          handleUint(fields[3], \"maxFeePerGas\"),\n        gasPrice:              null,\n        gasLimit:              handleUint(fields[4], \"gasLimit\"),\n        to:                    handleAddress(fields[5]),\n        value:                 handleUint(fields[6], \"value\"),\n        data:                  hexlify(fields[7]),\n        accessList:            handleAccessList(fields[8], \"accessList\"),\n        maxFeePerBlobGas:      handleUint(fields[9], \"maxFeePerBlobGas\"),\n        blobVersionedHashes:   fields[10],\n        blobWrapperVersion\n    };\n\n    if (blobs) { tx.blobs = blobs; }\n\n    assertArgument(tx.to != null, `invalid address for transaction type: ${ typeName }`, \"data\", data);\n\n    assertArgument(Array.isArray(tx.blobVersionedHashes), \"invalid blobVersionedHashes: must be an array\", \"data\", data);\n    for (let i = 0; i < tx.blobVersionedHashes.length; i++) {\n        assertArgument(isHexString(tx.blobVersionedHashes[i], 32), `invalid blobVersionedHash at index ${ i }: must be length 32`, \"data\", data);\n    }\n\n    // Unsigned EIP-4844 Transaction\n    if (fields.length === 11) { return tx; }\n\n    // @TODO: Do we need to do this? This is only called internally\n    // and used to verify hashes; it might save time to not do this\n    //tx.hash = keccak256(concat([ \"0x03\", encodeRlp(fields) ]));\n\n    _parseEipSignature(tx, fields.slice(11));\n\n    return tx;\n}\n\nfunction _serializeEip4844(tx: Transaction, sig: null | Signature, blobs: null | Array<Blob>): string {\n    const fields: Array<any> = [\n        formatNumber(tx.chainId, \"chainId\"),\n        formatNumber(tx.nonce, \"nonce\"),\n        formatNumber(tx.maxPriorityFeePerGas || 0, \"maxPriorityFeePerGas\"),\n        formatNumber(tx.maxFeePerGas || 0, \"maxFeePerGas\"),\n        formatNumber(tx.gasLimit, \"gasLimit\"),\n        (tx.to || ZeroAddress),\n        formatNumber(tx.value, \"value\"),\n        tx.data,\n        formatAccessList(tx.accessList || [ ]),\n        formatNumber(tx.maxFeePerBlobGas || 0, \"maxFeePerBlobGas\"),\n        formatHashes(tx.blobVersionedHashes || [ ], \"blobVersionedHashes\")\n    ];\n\n    if (sig) {\n        fields.push(formatNumber(sig.yParity, \"yParity\"));\n        fields.push(toBeArray(sig.r));\n        fields.push(toBeArray(sig.s));\n\n        // We have blobs; return the network wrapped format\n        if (blobs) {\n\n            // Use EIP-7594\n            if (tx.blobWrapperVersion != null) {\n                const wrapperVersion = toBeArray(tx.blobWrapperVersion);\n\n                const cellProofs: Array<Uint8Array> = [ ];\n                for (const { proof } of blobs) {\n                    const p = getBytes(proof);\n                    const cellSize = p.length / CELL_COUNT;\n                    for (let i = 0; i < p.length; i += cellSize) {\n                        cellProofs.push(p.subarray(i, i + cellSize));\n                    }\n                }\n\n                return concat([\n                    \"0x03\",\n                    encodeRlp([\n                        fields,\n                        wrapperVersion,\n                        blobs.map((b) => b.data),\n                        blobs.map((b) => b.commitment),\n                        cellProofs\n                    ])\n                ]);\n            }\n\n            // Fall back onto classic EIP-4844 behavior\n            return concat([\n                \"0x03\",\n                encodeRlp([\n                    fields,\n                    blobs.map((b) => b.data),\n                    blobs.map((b) => b.commitment),\n                    blobs.map((b) => b.proof),\n                ])\n            ]);\n\n        }\n\n    }\n\n    return concat([ \"0x03\", encodeRlp(fields)]);\n}\n\nfunction _parseEip7702(data: Uint8Array): TransactionLike {\n    const fields: any = decodeRlp(getBytes(data).slice(1));\n\n    assertArgument(Array.isArray(fields) && (fields.length === 10 || fields.length === 13),\n        \"invalid field count for transaction type: 4\", \"data\", hexlify(data));\n\n    const tx: TransactionLike = {\n        type:                  4,\n        chainId:               handleUint(fields[0], \"chainId\"),\n        nonce:                 handleNumber(fields[1], \"nonce\"),\n        maxPriorityFeePerGas:  handleUint(fields[2], \"maxPriorityFeePerGas\"),\n        maxFeePerGas:          handleUint(fields[3], \"maxFeePerGas\"),\n        gasPrice:              null,\n        gasLimit:              handleUint(fields[4], \"gasLimit\"),\n        to:                    handleAddress(fields[5]),\n        value:                 handleUint(fields[6], \"value\"),\n        data:                  hexlify(fields[7]),\n        accessList:            handleAccessList(fields[8], \"accessList\"),\n        authorizationList:     handleAuthorizationList(fields[9], \"authorizationList\"),\n    };\n\n    // Unsigned EIP-7702 Transaction\n    if (fields.length === 10) { return tx; }\n\n    _parseEipSignature(tx, fields.slice(10));\n\n    return tx;\n}\n\nfunction _serializeEip7702(tx: Transaction, sig: null | Signature): string {\n    const fields: Array<any> = [\n        formatNumber(tx.chainId, \"chainId\"),\n        formatNumber(tx.nonce, \"nonce\"),\n        formatNumber(tx.maxPriorityFeePerGas || 0, \"maxPriorityFeePerGas\"),\n        formatNumber(tx.maxFeePerGas || 0, \"maxFeePerGas\"),\n        formatNumber(tx.gasLimit, \"gasLimit\"),\n        (tx.to || \"0x\"),\n        formatNumber(tx.value, \"value\"),\n        tx.data,\n        formatAccessList(tx.accessList || [ ]),\n        formatAuthorizationList(tx.authorizationList || [ ])\n    ];\n\n    if (sig) {\n        fields.push(formatNumber(sig.yParity, \"yParity\"));\n        fields.push(toBeArray(sig.r));\n        fields.push(toBeArray(sig.s));\n    }\n\n    return concat([ \"0x04\", encodeRlp(fields)]);\n}\n\n/**\n *  A **Transaction** describes an operation to be executed on\n *  Ethereum by an Externally Owned Account (EOA). It includes\n *  who (the [[to]] address), what (the [[data]]) and how much (the\n *  [[value]] in ether) the operation should entail.\n *\n *  @example:\n *    tx = new Transaction()\n *    //_result:\n *\n *    tx.data = \"0x1234\";\n *    //_result:\n */\nexport class Transaction implements TransactionLike<string> {\n    #type: null | number;\n    #to: null | string;\n    #data: string;\n    #nonce: number;\n    #gasLimit: bigint;\n    #gasPrice: null | bigint;\n    #maxPriorityFeePerGas: null | bigint;\n    #maxFeePerGas: null | bigint;\n    #value: bigint;\n    #chainId: bigint;\n    #sig: null | Signature;\n    #accessList: null | AccessList;\n    #maxFeePerBlobGas: null | bigint;\n    #blobVersionedHashes: null | Array<string>;\n    #kzg: null | KzgLibrary;\n    #blobs: null | Array<Blob>;\n    #auths: null | Array<Authorization>;\n    #blobWrapperVersion: null | number;\n\n    /**\n     *  The transaction type.\n     *\n     *  If null, the type will be automatically inferred based on\n     *  explicit properties.\n     */\n    get type(): null | number { return this.#type; }\n    set type(value: null | number | string) {\n        switch (value) {\n            case null:\n                this.#type = null;\n                break;\n            case 0: case \"legacy\":\n                this.#type = 0;\n                break;\n            case 1: case \"berlin\": case \"eip-2930\":\n                this.#type = 1;\n                break;\n            case 2: case \"london\": case \"eip-1559\":\n                this.#type = 2;\n                break;\n            case 3: case \"cancun\": case \"eip-4844\":\n                this.#type = 3;\n                break;\n            case 4: case \"pectra\": case \"eip-7702\":\n                this.#type = 4;\n                break;\n            default:\n                assertArgument(false, \"unsupported transaction type\", \"type\", value);\n        }\n    }\n\n    /**\n     *  The name of the transaction type.\n     */\n    get typeName(): null | string {\n        switch (this.type) {\n            case 0: return \"legacy\";\n            case 1: return \"eip-2930\";\n            case 2: return \"eip-1559\";\n            case 3: return \"eip-4844\";\n            case 4: return \"eip-7702\";\n        }\n\n        return null;\n    }\n\n    /**\n     *  The ``to`` address for the transaction or ``null`` if the\n     *  transaction is an ``init`` transaction.\n     */\n    get to(): null | string {\n        const value = this.#to;\n        if (value == null && this.type === 3) { return ZeroAddress; }\n        return value;\n    }\n    set to(value: null | string) {\n        this.#to = (value == null) ? null: getAddress(value);\n    }\n\n    /**\n     *  The transaction nonce.\n     */\n    get nonce(): number { return this.#nonce; }\n    set nonce(value: BigNumberish) { this.#nonce = getNumber(value, \"value\"); }\n\n    /**\n     *  The gas limit.\n     */\n    get gasLimit(): bigint { return this.#gasLimit; }\n    set gasLimit(value: BigNumberish) { this.#gasLimit = getBigInt(value); }\n\n    /**\n     *  The gas price.\n     *\n     *  On legacy networks this defines the fee that will be paid. On\n     *  EIP-1559 networks, this should be ``null``.\n     */\n    get gasPrice(): null | bigint {\n        const value = this.#gasPrice;\n        if (value == null && (this.type === 0 || this.type === 1)) { return BN_0; }\n        return value;\n    }\n    set gasPrice(value: null | BigNumberish) {\n        this.#gasPrice = (value == null) ? null: getBigInt(value, \"gasPrice\");\n    }\n\n    /**\n     *  The maximum priority fee per unit of gas to pay. On legacy\n     *  networks this should be ``null``.\n     */\n    get maxPriorityFeePerGas(): null | bigint {\n        const value = this.#maxPriorityFeePerGas;\n        if (value == null) {\n            if (this.type === 2 || this.type === 3) { return BN_0; }\n            return null;\n        }\n        return value;\n    }\n    set maxPriorityFeePerGas(value: null | BigNumberish) {\n        this.#maxPriorityFeePerGas = (value == null) ? null: getBigInt(value, \"maxPriorityFeePerGas\");\n    }\n\n    /**\n     *  The maximum total fee per unit of gas to pay. On legacy\n     *  networks this should be ``null``.\n     */\n    get maxFeePerGas(): null | bigint {\n        const value = this.#maxFeePerGas;\n        if (value == null) {\n            if (this.type === 2 || this.type === 3) { return BN_0; }\n            return null;\n        }\n        return value;\n    }\n    set maxFeePerGas(value: null | BigNumberish) {\n        this.#maxFeePerGas = (value == null) ? null: getBigInt(value, \"maxFeePerGas\");\n    }\n\n    /**\n     *  The transaction data. For ``init`` transactions this is the\n     *  deployment code.\n     */\n    get data(): string { return this.#data; }\n    set data(value: BytesLike) { this.#data = hexlify(value); }\n\n    /**\n     *  The amount of ether (in wei) to send in this transactions.\n     */\n    get value(): bigint { return this.#value; }\n    set value(value: BigNumberish) {\n        this.#value = getBigInt(value, \"value\");\n    }\n\n    /**\n     *  The chain ID this transaction is valid on.\n     */\n    get chainId(): bigint { return this.#chainId; }\n    set chainId(value: BigNumberish) { this.#chainId = getBigInt(value); }\n\n    /**\n     *  If signed, the signature for this transaction.\n     */\n    get signature(): null | Signature { return this.#sig || null; }\n    set signature(value: null | SignatureLike) {\n        this.#sig = (value == null) ? null: Signature.from(value);\n    }\n\n    isValid(): boolean {\n        const sig = this.signature;\n        if (sig && !sig.isValid()) { return false; }\n\n        const auths = this.authorizationList;\n        if (auths) {\n            for (const auth of auths) {\n                if (!auth.signature.isValid()) { return false; }\n            }\n        }\n\n        return true;\n    }\n\n    /**\n     *  The access list.\n     *\n     *  An access list permits discounted (but pre-paid) access to\n     *  bytecode and state variable access within contract execution.\n     */\n    get accessList(): null | AccessList {\n        const value = this.#accessList || null;\n        if (value == null) {\n            if (this.type === 1 || this.type === 2 || this.type === 3) {\n                // @TODO: in v7, this should assign the value or become\n                // a live object itself, otherwise mutation is inconsistent\n                return [ ];\n            }\n            return null;\n        }\n        return value;\n    }\n    set accessList(value: null | AccessListish) {\n        this.#accessList = (value == null) ? null: accessListify(value);\n    }\n\n    get authorizationList(): null | Array<Authorization> {\n        const value = this.#auths || null;\n        if (value == null) {\n            if (this.type === 4) {\n                // @TODO: in v7, this should become a live object itself,\n                // otherwise mutation is inconsistent\n                return [ ];\n            }\n        }\n        return value;\n    }\n    set authorizationList(auths: null | Array<AuthorizationLike>) {\n        this.#auths = (auths == null) ? null: auths.map((a) =>\n          authorizationify(a));\n    }\n\n    /**\n     *  The max fee per blob gas for Cancun transactions.\n     */\n    get maxFeePerBlobGas(): null | bigint {\n        const value = this.#maxFeePerBlobGas;\n        if (value == null && this.type === 3) { return BN_0; }\n        return value;\n    }\n    set maxFeePerBlobGas(value: null | BigNumberish) {\n        this.#maxFeePerBlobGas = (value == null) ? null: getBigInt(value, \"maxFeePerBlobGas\");\n    }\n\n    /**\n     *  The BLOb versioned hashes for Cancun transactions.\n     */\n    get blobVersionedHashes(): null | Array<string> {\n        // @TODO: Mutation is inconsistent; if unset, the returned value\n        // cannot mutate the object, if set it can\n        let value = this.#blobVersionedHashes;\n        if (value == null && this.type === 3) { return [ ]; }\n        return value;\n    }\n    set blobVersionedHashes(value: null | Array<string>) {\n        if (value != null) {\n            assertArgument(Array.isArray(value), \"blobVersionedHashes must be an Array\", \"value\", value);\n            value = value.slice();\n            for (let i = 0; i < value.length; i++) {\n                assertArgument(isHexString(value[i], 32), \"invalid blobVersionedHash\", `value[${ i }]`, value[i]);\n            }\n        }\n        this.#blobVersionedHashes = value;\n    }\n\n    /**\n     *  The BLObs for the Transaction, if any.\n     *\n     *  If ``blobs`` is non-``null``, then the [[seriailized]]\n     *  will return the network formatted sidecar, otherwise it\n     *  will return the standard [[link-eip-2718]] payload. The\n     *  [[unsignedSerialized]] is unaffected regardless.\n     *\n     *  When setting ``blobs``, either fully valid [[Blob]] objects\n     *  may be specified (i.e. correctly padded, with correct\n     *  committments and proofs) or a raw [[BytesLike]] may\n     *  be provided.\n     *\n     *  If raw [[BytesLike]] are provided, the [[kzg]] property **must**\n     *  be already set. The blob will be correctly padded and the\n     *  [[KzgLibrary]] will be used to compute the committment and\n     *  proof for the blob.\n     *\n     *  A BLOb is a sequence of field elements, each of which must\n     *  be within the BLS field modulo, so some additional processing\n     *  may be required to encode arbitrary data to ensure each 32 byte\n     *  field is within the valid range.\n     *\n     *  Setting this automatically populates [[blobVersionedHashes]],\n     *  overwriting any existing values. Setting this to ``null``\n     *  does **not** remove the [[blobVersionedHashes]], leaving them\n     *  present.\n     */\n    get blobs(): null | Array<Blob> {\n        if (this.#blobs == null) { return null; }\n        return this.#blobs.map((b) => Object.assign({ }, b));\n    }\n    set blobs(_blobs: null | Array<BlobLike>) {\n        if (_blobs == null) {\n            this.#blobs = null;\n            return;\n        }\n\n        const blobs: Array<Blob> = [ ];\n        const versionedHashes: Array<string> = [ ];\n        for (let i = 0; i < _blobs.length; i++) {\n            const blob = _blobs[i];\n\n            if (isBytesLike(blob)) {\n                assert(this.#kzg, \"adding a raw blob requires a KZG library\", \"UNSUPPORTED_OPERATION\", {\n                    operation: \"set blobs()\"\n                });\n\n                let data = getBytes(blob);\n                assertArgument(data.length <= BLOB_SIZE, \"blob is too large\", `blobs[${ i }]`, blob);\n\n                // Pad blob if necessary\n                if (data.length !== BLOB_SIZE) {\n                    const padded = new Uint8Array(BLOB_SIZE);\n                    padded.set(data);\n                    data = padded;\n                }\n\n                const commit = this.#kzg.blobToKzgCommitment(data);\n                const proof = hexlify(this.#kzg.computeBlobKzgProof(data, commit));\n\n                blobs.push({\n                    data: hexlify(data),\n                    commitment: hexlify(commit),\n                    proof\n                });\n                versionedHashes.push(getVersionedHash(1, commit));\n\n            } else {\n                const data = hexlify(blob.data);\n                const commitment = hexlify(blob.commitment);\n                const proof = hexlify(blob.proof);\n                blobs.push({ data, commitment, proof });\n\n                versionedHashes.push(getVersionedHash(1, commitment));\n            }\n        }\n\n        this.#blobs = blobs;\n        this.#blobVersionedHashes = versionedHashes;\n    }\n\n    get kzg(): null | KzgLibrary { return this.#kzg; }\n    set kzg(kzg: null | KzgLibraryLike) {\n        if (kzg == null) {\n            this.#kzg = null;\n        } else {\n            this.#kzg = getKzgLibrary(kzg);\n        }\n    }\n\n    get blobWrapperVersion(): null | number {\n        return this.#blobWrapperVersion;\n    }\n    set blobWrapperVersion(value: null | number) {\n        this.#blobWrapperVersion = value;\n    }\n\n    /**\n     *  Creates a new Transaction with default values.\n     */\n    constructor() {\n        this.#type = null;\n        this.#to = null;\n        this.#nonce = 0;\n        this.#gasLimit = BN_0;\n        this.#gasPrice = null;\n        this.#maxPriorityFeePerGas = null;\n        this.#maxFeePerGas = null;\n        this.#data = \"0x\";\n        this.#value = BN_0;\n        this.#chainId = BN_0;\n        this.#sig = null;\n        this.#accessList = null;\n        this.#maxFeePerBlobGas = null;\n        this.#blobVersionedHashes = null;\n        this.#kzg = null;\n        this.#blobs = null;\n        this.#auths = null;\n        this.#blobWrapperVersion = null;\n    }\n\n    /**\n     *  The transaction hash, if signed. Otherwise, ``null``.\n     */\n    get hash(): null | string {\n        if (this.signature == null) { return null; }\n        return keccak256(this.#getSerialized(true, false));\n    }\n\n    /**\n     *  The pre-image hash of this transaction.\n     *\n     *  This is the digest that a [[Signer]] must sign to authorize\n     *  this transaction.\n     */\n    get unsignedHash(): string {\n        return keccak256(this.unsignedSerialized);\n    }\n\n    /**\n     *  The sending address, if signed. Otherwise, ``null``.\n     */\n    get from(): null | string {\n        if (this.signature == null) { return null; }\n        return recoverAddress(this.unsignedHash, this.signature.getCanonical());\n    }\n\n    /**\n     *  The public key of the sender, if signed. Otherwise, ``null``.\n     */\n    get fromPublicKey(): null | string {\n        if (this.signature == null) { return null; }\n        return SigningKey.recoverPublicKey(this.unsignedHash, this.signature.getCanonical());\n    }\n\n    /**\n     *  Returns true if signed.\n     *\n     *  This provides a Type Guard that properties requiring a signed\n     *  transaction are non-null.\n     */\n    isSigned(): this is (Transaction & { type: number, typeName: string, from: string, signature: Signature }) {\n        return this.signature != null;\n    }\n\n    #getSerialized(signed: boolean, sidecar: boolean): string {\n        assert(!signed || this.signature != null, \"cannot serialize unsigned transaction; maybe you meant .unsignedSerialized\", \"UNSUPPORTED_OPERATION\", { operation: \".serialized\"});\n\n        const sig = signed ? this.signature: null;\n        switch (this.inferType()) {\n            case 0:\n                return _serializeLegacy(this, sig);\n            case 1:\n                return _serializeEip2930(this, sig);\n            case 2:\n                return _serializeEip1559(this, sig);\n            case 3:\n                return _serializeEip4844(this, sig, sidecar ? this.blobs: null);\n            case 4:\n                return _serializeEip7702(this, sig);\n        }\n\n        assert(false, \"unsupported transaction type\", \"UNSUPPORTED_OPERATION\", { operation: \".serialized\" });\n    }\n\n    /**\n     *  The serialized transaction.\n     *\n     *  This throws if the transaction is unsigned. For the pre-image,\n     *  use [[unsignedSerialized]].\n     */\n    get serialized(): string {\n        return this.#getSerialized(true, true);\n    }\n\n    /**\n     *  The transaction pre-image.\n     *\n     *  The hash of this is the digest which needs to be signed to\n     *  authorize this transaction.\n     */\n    get unsignedSerialized(): string {\n        return this.#getSerialized(false, false);\n    }\n\n    /**\n     *  Return the most \"likely\" type; currently the highest\n     *  supported transaction type.\n     */\n    inferType(): number {\n        const types = this.inferTypes();\n\n        // Prefer London (EIP-1559) over Cancun (BLOb)\n        if (types.indexOf(2) >= 0) { return 2; }\n\n        // Return the highest inferred type\n        return <number>(types.pop());\n    }\n\n    /**\n     *  Validates the explicit properties and returns a list of compatible\n     *  transaction types.\n     */\n    inferTypes(): Array<number> {\n\n        // Checks that there are no conflicting properties set\n        const hasGasPrice = this.gasPrice != null;\n        const hasFee = (this.maxFeePerGas != null || this.maxPriorityFeePerGas != null);\n        const hasAccessList = (this.accessList != null);\n        const hasBlob = (this.#maxFeePerBlobGas != null || this.#blobVersionedHashes);\n\n        //if (hasGasPrice && hasFee) {\n        //    throw new Error(\"transaction cannot have gasPrice and maxFeePerGas\");\n        //}\n\n        if (this.maxFeePerGas != null && this.maxPriorityFeePerGas != null) {\n            assert(this.maxFeePerGas >= this.maxPriorityFeePerGas, \"priorityFee cannot be more than maxFee\", \"BAD_DATA\", { value: this });\n        }\n\n        //if (this.type === 2 && hasGasPrice) {\n        //    throw new Error(\"eip-1559 transaction cannot have gasPrice\");\n        //}\n\n        assert(!hasFee || (this.type !== 0 && this.type !== 1), \"transaction type cannot have maxFeePerGas or maxPriorityFeePerGas\", \"BAD_DATA\", { value: this });\n        assert(this.type !== 0 || !hasAccessList, \"legacy transaction cannot have accessList\", \"BAD_DATA\", { value: this })\n\n        const types: Array<number> = [ ];\n\n        // Explicit type\n        if (this.type != null) {\n            types.push(this.type);\n\n        } else {\n            if (this.authorizationList && this.authorizationList.length) {\n                types.push(4);\n            } else if (hasFee) {\n                types.push(2);\n            } else if (hasGasPrice) {\n                types.push(1);\n                if (!hasAccessList) { types.push(0); }\n            } else if (hasAccessList) {\n                types.push(1);\n                types.push(2);\n            } else if (hasBlob && this.to) {\n                types.push(3);\n            } else {\n                types.push(0);\n                types.push(1);\n                types.push(2);\n                types.push(3);\n            }\n        }\n\n        types.sort();\n\n        return types;\n    }\n\n    /**\n     *  Returns true if this transaction is a legacy transaction (i.e.\n     *  ``type === 0``).\n     *\n     *  This provides a Type Guard that the related properties are\n     *  non-null.\n     */\n    isLegacy(): this is (Transaction & { type: 0, gasPrice: bigint }) {\n        return (this.type === 0);\n    }\n\n    /**\n     *  Returns true if this transaction is berlin hardform transaction (i.e.\n     *  ``type === 1``).\n     *\n     *  This provides a Type Guard that the related properties are\n     *  non-null.\n     */\n    isBerlin(): this is (Transaction & { type: 1, gasPrice: bigint, accessList: AccessList }) {\n        return (this.type === 1);\n    }\n\n    /**\n     *  Returns true if this transaction is london hardform transaction (i.e.\n     *  ``type === 2``).\n     *\n     *  This provides a Type Guard that the related properties are\n     *  non-null.\n     */\n    isLondon(): this is (Transaction & { type: 2, accessList: AccessList, maxFeePerGas: bigint, maxPriorityFeePerGas: bigint }) {\n        return (this.type === 2);\n    }\n\n    /**\n     *  Returns true if this transaction is an [[link-eip-4844]] BLOB\n     *  transaction.\n     *\n     *  This provides a Type Guard that the related properties are\n     *  non-null.\n     */\n    isCancun(): this is (Transaction & { type: 3, to: string, accessList: AccessList, maxFeePerGas: bigint, maxPriorityFeePerGas: bigint, maxFeePerBlobGas: bigint, blobVersionedHashes: Array<string> }) {\n        return (this.type === 3);\n    }\n\n    /**\n     *  Create a copy of this transaciton.\n     */\n    clone(): Transaction {\n        return Transaction.from(this);\n    }\n\n    /**\n     *  Return a JSON-friendly object.\n     */\n    toJSON(): any {\n        const s = (v: null | bigint) => {\n            if (v == null) { return null; }\n            return v.toString();\n        };\n\n        return {\n            type: this.type,\n            to: this.to,\n//            from: this.from,\n            data: this.data,\n            nonce: this.nonce,\n            gasLimit: s(this.gasLimit),\n            gasPrice: s(this.gasPrice),\n            maxPriorityFeePerGas: s(this.maxPriorityFeePerGas),\n            maxFeePerGas: s(this.maxFeePerGas),\n            value: s(this.value),\n            chainId: s(this.chainId),\n            sig: this.signature ? this.signature.toJSON(): null,\n            accessList: this.accessList\n        };\n    }\n\n    [inspect](): string {\n        return this.toString();\n    }\n\n    toString(): string {\n        const output: Array<string> = [ ];\n        const add = (key: string) => {\n            let value = (<any>this)[key];\n            if (typeof(value) === \"string\") { value = JSON.stringify(value); }\n            output.push(`${ key }: ${ value }`);\n        };\n\n        if (this.type) { add(\"type\"); }\n        add(\"to\");\n        add(\"data\");\n        add(\"nonce\");\n        add(\"gasLimit\");\n        add(\"value\");\n        if (this.chainId != null) { add(\"chainId\"); }\n        if (this.signature) {\n            add(\"from\");\n            output.push(`signature: ${ this.signature.toString() }`);\n        }\n\n        // @TODO: accessList\n\n        // @TODO: blobs (might make output huge; maybe just include a flag?)\n\n        const auths = this.authorizationList;\n        if (auths) {\n            const outputAuths: Array<string> = [ ];\n            for (const auth of auths) {\n                const o: Array<string> = [ ];\n                o.push(`address: ${ JSON.stringify(auth.address) }`);\n                if (auth.nonce != null) { o.push(`nonce: ${ auth.nonce }`); }\n                if (auth.chainId != null) { o.push(`chainId: ${ auth.chainId }`); }\n                if (auth.signature) {\n                    o.push(`signature: ${ auth.signature.toString() }`);\n                }\n                outputAuths.push(`Authorization { ${ o.join(\", \") } }`);\n            }\n            output.push(`authorizations: [ ${ outputAuths.join(\", \") } ]`);\n        }\n\n        return `Transaction { ${ output.join(\", \") } }`;\n    }\n\n    /**\n     *  Create a **Transaction** from a serialized transaction or a\n     *  Transaction-like object.\n     */\n    static from(tx?: string | TransactionLike<string>): Transaction {\n        if (tx == null) { return new Transaction(); }\n\n        if (typeof(tx) === \"string\") {\n            const payload = getBytes(tx);\n\n            if (payload[0] >= 0x7f) { // @TODO: > vs >= ??\n                return Transaction.from(_parseLegacy(payload));\n            }\n\n            switch(payload[0]) {\n                case 1: return Transaction.from(_parseEip2930(payload));\n                case 2: return Transaction.from(_parseEip1559(payload));\n                case 3: return Transaction.from(_parseEip4844(payload));\n                case 4: return Transaction.from(_parseEip7702(payload));\n            }\n            assert(false, \"unsupported transaction type\", \"UNSUPPORTED_OPERATION\", { operation: \"from\" });\n        }\n\n        const result = new Transaction();\n        if (tx.type != null) { result.type = tx.type; }\n        if (tx.to != null) { result.to = tx.to; }\n        if (tx.nonce != null) { result.nonce = tx.nonce; }\n        if (tx.gasLimit != null) { result.gasLimit = tx.gasLimit; }\n        if (tx.gasPrice != null) { result.gasPrice = tx.gasPrice; }\n        if (tx.maxPriorityFeePerGas != null) { result.maxPriorityFeePerGas = tx.maxPriorityFeePerGas; }\n        if (tx.maxFeePerGas != null) { result.maxFeePerGas = tx.maxFeePerGas; }\n        if (tx.maxFeePerBlobGas != null) { result.maxFeePerBlobGas = tx.maxFeePerBlobGas; }\n        if (tx.data != null) { result.data = tx.data; }\n        if (tx.value != null) { result.value = tx.value; }\n        if (tx.chainId != null) { result.chainId = tx.chainId; }\n        if (tx.signature != null) { result.signature = Signature.from(tx.signature); }\n        if (tx.accessList != null) { result.accessList = tx.accessList; }\n        if (tx.authorizationList != null) {\n            result.authorizationList = tx.authorizationList;\n        }\n\n        // This will get overwritten by blobs, if present\n        if (tx.blobVersionedHashes != null) { result.blobVersionedHashes = tx.blobVersionedHashes; }\n\n        // Make sure we assign the kzg before assigning blobs, which\n        // require the library in the event raw blob data is provided.\n        if (tx.kzg != null) { result.kzg = tx.kzg; }\n        if (tx.blobWrapperVersion != null) { result.blobWrapperVersion = tx.blobWrapperVersion; }\n        if (tx.blobs != null) { result.blobs = tx.blobs; }\n\n        if (tx.hash != null) {\n            assertArgument(result.isSigned(), \"unsigned transaction cannot define '.hash'\", \"tx\", tx);\n            assertArgument(result.hash === tx.hash, \"hash mismatch\", \"tx\", tx);\n        }\n\n        if (tx.from != null) {\n            assertArgument(result.isSigned(), \"unsigned transaction cannot define '.from'\", \"tx\", tx);\n            assertArgument(result.from.toLowerCase() === (tx.from || \"\").toLowerCase(), \"from mismatch\", \"tx\", tx);\n        }\n\n        return result;\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}